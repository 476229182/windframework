<?php L::setImports(array("IWindApplication"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\base\IWindApplication.php","WindBaseAction"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\base\WindBaseAction.php","WindServlet"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\base\WindServlet.php","WindController"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindController.php","WindDispatcher"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindDispatcher.php","WindErrorAction"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindErrorAction.php","WindErrorHandle"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindErrorHandle.php","WindErrorMessage"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindErrorMessage.php","WindFrontController"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindFrontController.php","WindModelAndView"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindModelAndView.php","WindSystemConfig"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindSystemConfig.php","WindWebApplication"=>"D:\PHPAPP\phpwindframework\trunk\wind\core\WindWebApplication.php",));  Interface IWindApplication { public function init(); public function processRequest($request, $response); public function destory(); }  abstract class WindBaseAction { private $request; private $response; protected $mav = null; protected $error = null; public function __construct($request, $response) { $this->mav = new WindModelAndView(); $this->request = $request; $this->response = $response; $this->setDefaultViewTemplate(); $this->error = WindErrorMessage::getInstance(); } public function beforeAction() {} abstract public function run(); public function afterAction() {} public function setViewData($data, $key = '') { $this->response->setData($data, $key); } public function setDefaultViewTemplate($default = '') { if (!$default && $this->response) { $default = $this->response->getDispatcher()->getController() . '_' . $this->response->getDispatcher()->getAction(); } $this->mav->setViewName($default); } public function setTemplate($template = '') { if ($template) $this->getModelAndView()->setViewName($template); } public function setLayout($layout = '') { if ($layout instanceof WindLayout) { $this->getModelAndView()->setLayout($layout); } } public function addError($message, $key = '') { $this->error->addError($message, $key); } public function addErrorAction($errorAction) { $this->error->setErrorAction($errorAction); } public function sendError($message = '', $key = '', $errorAction = '') { $this->addError($message, $key); $this->addErrorAction($errorAction); $this->error->sendError(); } public function getModelAndView() { return $this->mav; } } L::import('WIND:component.exception.WindException'); L::import('WIND:component.request.WindHttpRequest'); L::import('WIND:component.request.WindHttpResponse'); abstract class WindServlet { protected $request = null; protected $response = null; const METHOD_DELETE = "DELETE"; const METHOD_HEAD = "HEAD"; const METHOD_GET = "GET"; const METHOD_OPTIONS = "OPTIONS"; const METHOD_POST = "POST"; const METHOD_PUT = "PUT"; const METHOD_TRACE = "TRACE"; protected function __construct() { try { $this->request = WindHttpRequest::getInstance(); $this->response = $this->request->getResponse(); } catch (Exception $exception) { throw new WindException('init action servlet failed!!'); } } public function run() { if ($this->request === null || $this->response === null) throw new WindException('init action servlet failed!!'); $this->service($this->request, $this->response); $this->response->sendResponse(); } abstract function process($request, $resopnse); protected function service(WindHttpRequest $request, WindHttpResponse $response) { $method = $request->getRequestMethod(); if (strcasecmp($method, self::METHOD_GET) == 0) { $this->doGet($request, $response); } else if (strcasecmp($method, self::METHOD_POST) == 0) { $this->doPost($request, $response); } else if (strcasecmp($method, self::METHOD_PUT) == 0) { $this->doPut($request, $response); } else if (strcasecmp($method, self::METHOD_DELETE) == 0) { $this->doDelete($request, $response); } else if (strcasecmp($method, self::METHOD_HEAD) == 0) { } else if (strcasecmp($method, self::METHOD_OPTIONS) == 0) { } else if (strcasecmp($method, self::METHOD_TRACE) == 0) { } else { $errMsg = 'your request method is not supported!!!'; $response->sendError(WindHttpResponse::SC_METHOD_NOT_ALLOWED, $errMsg); } } protected function doPost(WindHttpRequest $request, WindHttpResponse $response) { $protocol = $request->getProtocol(); $msg = "The method post is not supported."; if (!$protocol || (strpos($protocol, '1.1')) !== false) { $response->sendError(WindHttpResponse::SC_METHOD_NOT_ALLOWED, $msg); } else $this->process($request, $response); } protected function doGet(WindHttpRequest $request, WindHttpResponse $response) { $protocol = $request->getProtocol(); $msg = "The method get is not supported."; if (!$protocol || (strpos($protocol, '1.1')) !== false) { $response->sendError(WindHttpResponse::SC_METHOD_NOT_ALLOWED, $msg); } else $this->process($request, $response); } protected function doPut(WindHttpRequest $request, WindHttpResponse $response) { $this->process($request, $response); } protected function doDelete(WindHttpRequest $request, WindHttpResponse $response) { $this->process($request, $response); } protected function doTrace(WindHttpRequest $request, WindHttpResponse $response) { } protected function doOptions(WindHttpRequest $request, WindHttpResponse $response) { } protected function doHead(WindHttpRequest $request, WindHttpResponse $response) { } }  class WindController extends WindBaseAction { public function run() {} } class WindDispatcher { private $action = 'run'; private $controller = 'index'; private $module = 'apps'; private $mav = null; private $mavs = array(); private $request = null; private $response = null; private static $instance = null; private $actionHandle = ''; private function __construct($request, $response) { $this->request = $request; $this->response = $response; } public function dispatch() { if ($this->getMav() === null) throw new WindException('dispatch error.'); if (($redirect = $this->getMav()->getRedirect()) !== '') $this->_dispatchWithRedirect($redirect); elseif (($action = $this->getMav()->getAction()) !== '') $this->_dispatchWithAction($action); else $this->_dispatchWithTemplate(); return; } private function _dispatchWithRedirect($redirect) { $this->response->sendRedirect($redirect); } private function _dispatchWithAction($action) { WindFrontController::getInstance()->getApplicationHandle()->processRequest($this->request, $this->response); } private function _dispatchWithTemplate() { $viewer = $this->getMav()->getView()->createViewerResolver(); $viewer->windAssign($this->response->getData()); $viewName = $this->getMav()->getViewName(); $this->response->setBody($viewer->windFetch(), $viewName); } public function getMav() { return $this->mav; } public function setMav($mav) { if ($mav instanceof WindModelAndView) { $this->mavs[] = $mav; $this->initWithModelAndView($mav); } else throw new WindException('The type of object error.'); return $this; } private function initWithModelAndView($mav) { $this->mav = $mav; $this->action = $mav->getAction(); $path = $this->getMav()->getActionPath(); if (!$path) return; if (($pos = strrpos($path, '.')) !== false) { $this->controller = substr($path, $pos + 1); $this->module = substr($path, 0, $pos); } else $this->controller = $path; } public function initWithRouter($router) { if ($router instanceof WindRouter) { $this->module = $router->getModule(); $this->controller = $router->getController(); $this->action = $router->getAction(); } return $this; } public function getActionHandle() { $moduleConfig = C::getModules($this->module); $module = $moduleConfig ? $moduleConfig[IWindConfig::MODULE_PATH] : $this->module; $path = $module . '.' . $this->controller; $method = $this->action; list($className, $realPath) = $this->matchActionHandle($path); if (!$realPath) { list($className, $realPath) = $this->matchActionHandle($path, 'Controller'); } if (!$realPath) { $path .= $this->action; list($className, $realPath) = $this->matchActionHandle($path, 'Action'); $method = 'run'; } L::import($realPath); if (!class_exists($className) || !in_array($method, get_class_methods($className))) { return array(null, null); } return array($className, $method); } private function matchActionHandle($path, $match = '') { if ($match && !preg_match("/" . $match . "$/i", $path)) { $path .= $match; } list(, $className, , $realPath) = L::getRealPath($path, true); return array($className, $realPath); } static public function getInstance($request = null, $response = null) { if (self::$instance === null) { $class = __CLASS__; self::$instance = new $class($request, $response); } return self::$instance; } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function getModule() { return $this->module; } static public function clear() { self::$instance = null; } }  class WindErrorAction extends WindBaseAction { public function run() { echo "error action"; } } class WindErrorHandle { static public function exceptionHandle($exception) { $message = 'Uncaught exception'; echo self::buildErrorMessage($exception->getMessage(), $exception->getFile(), $exception->getLine(), $message); echo $exception->getTraceAsString(); } static public function errorHandle($errno, $errstr, $errfile, $errline) { switch ($errno) { case E_USER_ERROR: echo self::buildErrorMessage($errstr, $errfile, $errline, 'ERROR'); exit(1); break; case E_USER_WARNING: echo self::buildMessage($errstr, $errfile, $errline, 'WARNING'); break; case E_USER_NOTICE: echo self::buildMessage($errstr, $errfile, $errline, 'NOTICE'); break; default: break; } } static public function buildErrorMessage($errstr, $errfile, $errline, $type = '') { $message = self::buildMessage($errstr, $errfile, $errline, $type); $message .= "PHP " . PHP_VERSION . "(" . PHP_OS . ")\n"; $message .= "Aborting...\n"; return $message; } static public function buildMessage($errstr, $errfile, $errline, $type = '') { $message = "Error Type: $type\nError Message: $errstr\n"; $message .= "Info: on line $errline in file $errfile \n"; return $message; } } L::import('WIND:component.message.WindMessage'); class WindErrorMessage extends WindMessage { private $errorAction = ''; private static $instance = null; private function __construct() {} private $mav = null; public function addError($message, $key = '') { parent::addMessage($message, $key); } public function getError($key = '') { return parent::getMessage($key); } public function setErrorAction($action = '') { $this->errorAction = $action; } public function sendError() { if ($this->errorAction === '') { $this->errorAction = C::getErrorMessage(IWindConfig::ERRORMESSAGE_ERRORACTION); } if ($this->mav === null) { $this->mav = new WindModelAndView(); $this->mav->setAction('run', $this->errorAction); } WindDispatcher::getInstance()->setMav($this->mav)->dispatch(); exit(); } static public function &getInstance() { if (self::$instance === null) { $class = __CLASS__; self::$instance = new $class(); } return self::$instance; } }  L::import('WIND:component.exception.WindException'); class WindFrontController extends WindServlet { private $applications = array(); private static $instance = null; protected function __construct() { parent::__construct(); $this->initConfig(); } public function run() { $this->beforProcess(); parent::run(); $this->afterProcess(); } protected function beforProcess() { $this->initDispatch(); } public function process($request, $response) { if ($this->initFilter()) return; $applicationController = $this->getApplicationHandle(); $applicationController->init(); $applicationController->processRequest($request, $response); $applicationController->destory(); } protected function afterProcess() { restore_exception_handler(); } protected function doPost($request, $response) { $this->process($request, $response); } protected function doGet($request, $response) { $this->process($request, $response); } private function initFilter() { $filters = C::getConfig(IWindConfig::FILTERS); if (empty($filters)) return; L::import('WIND:component.filter.WindFilterFactory'); WindFilterFactory::getFactory()->setExecute(array($this, 'process'), $this->request, $this->response); $filter = WindFilterFactory::getFactory()->create(); if ($filter instanceof WindFilter) { $filter->doFilter($this->request, $this->response); return false; } return true; } private function initConfig() { L::import('WIND:component.config.WindConfigParser'); $configParser = new WindConfigParser(); $appConfig = $configParser->parser($this->request); C::init($appConfig); } protected function initDispatch() { if ($this->response->getDispatcher() && $this->response->getDispatcher()->getAction()) return; $router = WindRouterFactory::getFactory()->create(); $router->doParser($this->request, $this->response); $this->response->setDispatcher(WindDispatcher::getInstance($this->request, $this->response)->initWithRouter($router)); } public function &getApplicationHandle($key = 'default') { if (!isset($this->applications[$key])) { $application = C::getApplications($key); list(, $className, , $realpath) = L::getRealPath($application[IWindConfig::APPLICATIONS_CLASS], true); L::import($realpath); $this->applications[$key] = &new $className(); } return $this->applications[$key]; } static public function &getInstance() { if (self::$instance === null) { $class = __CLASS__; self::$instance = new $class(); } return self::$instance; } } class WindModelAndView { private $viewName = ''; private $path = ''; private $redirect = ''; private $action = ''; private $actionPath = ''; private $view = null; private $layoutMapping = array(); private $layout = null; public function __construct() {} public function setLayout($layout) { if ($layout instanceof WindLayout) { $this->layout = $layout; } else throw new WindException('object type error.'); } public function &getLayout() { return $this->layout; } public function getLayoutMapping() { return $this->layoutMapping; } public function setRedirect($redirect) { if (!$redirect) return; $this->redirect = $redirect; } public function getRedirect() { return $this->redirect; } public function setViewName($viewName, $key = 'current') { if (!$viewName) return; $this->layoutMapping['key_' . $key] = $viewName; $this->viewName = $viewName; } public function getViewName() { return $this->viewName; } public function setView($view = null) { $this->view = $view; } public function getView() { if ($this->view == null) { L::import('WIND:component.viewer.WindView'); $this->view = new WindView(); $this->view->setViewWithObject($this); } return $this->view; } public function setPath($path) { $this->path = $path; } public function getPath() { return $this->path; } public function getAction() { return $this->action; } public function setAction($action, $path = '') { $this->action = $action; if ($path) $this->setActionPath($path); } public function getActionPath() { return $this->actionPath; } public function setActionPath($actionPath) { $this->actionPath = $actionPath; } } class WindSystemConfig { private $config = array(); private static $instance = null; public function __construct($configSystem) { if (empty($configSystem)) throw new Exception('system config file is not exists!!!'); $this->config = $configSystem; } public function getConfig($configName) { if ($configName && isset($this->config[$configName])) return $this->config[$configName]; } public function getConfigPath() { $vars = func_get_args(); $current = $this->config; foreach ($vars as $name) { if (isset($current[$name])) $current = $current[$name]; return ''; } return $current; } public function getFiltersConfig($name = '') { if (!$this->config[IWindConfig::FILTERS]) return array(); if ($name == '') return $this->config[IWindConfig::FILTERS]; $filters = $this->config[IWindConfig::FILTERS]; foreach ($filters as $one) { if ($one[IWindConfig::FILTERNAME] == $name) return $one; } } public function getModulesConfig($name = '', $default = null) { if (!isset($this->config['app'])) return $default; if (!$name) return $this->config['app']; return $this->config['app'][$name] ? $this->config['app'][$name] : $default; } public function getRouterConfig($name = '', $default = null) { if (!isset($this->config['router'])) return $default; if (!$name) return $this->config['router']; return isset($this->config['router'][$name]) ? $this->config['router'][$name] : $default; } public function getRouterRule($name = '', $default = null) { if ($name) { $name = $name . 'Rule'; return isset($this->config[$name]) ? $this->config[$name] : $default; } else throw new WindException(''); } public function getRouterParser($name = '', $default = null) { if (!isset($this->config['routerParser'])) return $default; if (!$name) return $this->config['routerParser']; return $this->config['routerParser'][$name] ? $this->config['routerParser'][$name] : $default; } static public function getInstance($config = '') { if (self::$instance === null) { $class = __CLASS__; self::$instance = new $class($config); } return self::$instance; } }  L::import('WIND:component.exception.WindException'); L::import('WIND:component.viewer.WindViewFactory'); L::import('WIND:component.router.WindRouterFactory'); class WindWebApplication implements IWindApplication { protected $process = ''; public function init() {} public function processRequest($request, $response) { list($action, $method) = $this->getActionHandle($request, $response); $action->beforeAction(); $action->$method($request, $response); $action->afterAction(); $mav = $action->getModelAndView(); $this->processDispatch($request, $response, $mav); } protected function getActionHandle($request, $response) { list($className, $method) = WindDispatcher::getInstance()->getActionHandle(); $this->checkReprocess($className . '_' . $method); if ($className === null || $method === null) { throw new WindException('can\'t create action handle.'); } $action = new $className($request, $response); return array($action, $method); } protected function checkReprocess($key = '') { if ($this->process && $this->process === $key) { echo 'Duplicate request \'' . $key . '\''; exit(); } $this->process = $key; } protected function processDispatch($request, $response, $mav) { WindDispatcher::getInstance()->setMav($mav)->dispatch(); } public function destory() { WindDispatcher::getInstance()->clear(); } }?>