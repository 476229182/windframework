<?php  Wind::import('COM:utility.WindUtility'); class WindModule { protected $_config = array(); protected $_typeValidation = false; private $delayAttributes = array(); public function __set($propertyName, $value) { $_setter = 'set' . ucfirst($propertyName); if (method_exists($this, $_setter)) $this->$_setter($value); else Wind::log( '[core.WindModule.__set] both of property and setter are not exist. ' . $propertyName, WindLogger::LEVEL_DEBUG, 'wind.core'); } public function __get($propertyName) { $_getter = 'get' . ucfirst($propertyName); if (method_exists($this, $_getter)) return $this->$_getter(); else Wind::log( '[core.WindModule.__set] both of property and getter are not exist. ' . $propertyName, WindLogger::LEVEL_DEBUG, 'wind.core'); } public function __call($methodName, $args) { $_prefix = substr($methodName, 0, 4); $_propertyName = substr($methodName, 4); $_propertyName = WindUtility::lcfirst($_propertyName); if ($_prefix == '_get') { if (isset($this->delayAttributes[$_propertyName])) { $_property = $this->delayAttributes[$_propertyName]; $_value = null; if (isset($_property['value'])) { $_value = $_property['value']; } elseif (isset($_property['ref'])) { $_value = $this->getSystemFactory()->getInstance($_property['ref'], $args); } elseif (isset($_property['path'])) { $_className = Wind::import($_property['path']); $_value = $this->getSystemFactory()->createInstance($_className, $args); } $this->$_propertyName = $_value; unset($this->delayAttributes[$_propertyName]); } return $this->$_propertyName; } elseif ($_prefix == '_set') { $this->$_propertyName = $args[0]; } throw new WindException( '[core.WindModule.__call] ' . get_class($this) . '->' . $methodName . '()', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } public function __clone() { foreach ($this->writeTableCloneProperty() as $value) { if (!is_object($this->$value) || !isset($this->$value)) { Wind::log( "[core.WindModule.__clone] unexcepted value type or the property  					is not setted.(" . $value . ") need an object type in here. 					", WindLogger::LEVEL_DEBUG, 'wind.core'); continue; } $this->$value = clone $this->$value; } } public function toArray() { $reflection = new ReflectionClass(get_class($this)); $properties = $reflection->getProperties(); $_result = array(); foreach ($properties as $property) { $_propertyName = $property->name; $_result[$_propertyName] = $this->$_propertyName; } return $_result; } protected function validatePropertyName($propertyName, $value = null) { if (isset($this->delayAttributes[$propertyName])) { Wind::log( '[core.WindModule.validatePropertyName] is a delay property  (' . $propertyName . ')', WindLogger::LEVEL_DEBUG, 'wind.core'); return true; } if (!($_writeTableProperties = $this->writeTableForProperty())) { Wind::log( "[core.WindModule.validatePropertyName]  				writeTableForProperty is empty or your input is not exists. 				(" . $propertyName . ")", WindLogger::LEVEL_DEBUG, 'wind.core'); return false; } if (!array_key_exists($propertyName, $_writeTableProperties)) { Wind::log( "[core.WindModule.validatePropertyName]  				writeTableForProperty is empty or your input is not exists. 				(" . $propertyName . ")", WindLogger::LEVEL_DEBUG, 'wind.core'); return false; } if ($this->_typeValidation && $_writeTableProperties[$propertyName]) { if ($value instanceof $_writeTableProperties[$propertyName]) return true; Wind::log( "[core.WindModule.validatePropertyName] 				type of the property " . $propertyName . " is not defined. 				", WindLogger::LEVEL_DEBUG, 'wind.core'); return false; } return true; } public function getConfig($configName = '', $subConfigName = '', $default = '', $config = array()) { if (empty($config)) $config = $this->_config; if ($configName === '') return $config; if (!isset($config[$configName])) return $default; if ($subConfigName === '') return $config[$configName]; if (!isset($config[$configName][$subConfigName])) return $default; return $config[$configName][$subConfigName]; } public function setConfig($config) { if (!$config) return; if (is_string($config)) { $configParser = $this->getSystemFactory()->getInstance('configParser'); $config = $configParser->parse($config); } if (!$this->_config) { $this->_config = array_merge($this->_config, (array) $config); } else $this->_config = $config; } protected function writeTableForProperty() { return array('delayAttributes' => 'array'); } protected function writeTableCloneProperty() { return array(); } protected function getSystemFactory() { return Wind::getApp()->getWindFactory(); } protected function getRequest() { return Wind::getApp()->getRequest(); } protected function getResponse() { return Wind::getApp()->getResponse(); } public function setDelayAttributes($delayAttributes) { $this->delayAttributes = array_merge($this->delayAttributes, $delayAttributes); } }   class WindLogger extends WindModule { const LEVEL_INFO = 1; const LEVEL_TRACE = 2; const LEVEL_DEBUG = 3; const LEVEL_ERROR = 4; const LEVEL_PROFILE = 5; const TOKEN_BEGIN = 'begin:'; const TOKEN_END = 'end:'; const WRITE_ALL = 0; const WRITE_LEVEL = 1; const WRITE_TYPE = 2; private $_autoFlush = 1000; private $_logs = array(); private $_logCount = 0; private $_profiles = array(); private $_logDir; private $_maxFileSize = 100; private $_writeType = '0'; private $_types = array(); public function __construct($logDir = '', $writeType = 0) { $this->_logDir = $logDir; $this->_writeType = $writeType; } public function info($msg, $type = 'wind.system') { $this->log($msg, self::LEVEL_INFO, $type); } public function trace($msg, $type = 'wind.system') { $this->log($msg, self::LEVEL_TRACE, $type); } public function debug($msg, $type = 'wind.system') { $this->log($msg, self::LEVEL_DEBUG, $type); } public function error($msg, $type = 'wind.core') { $this->log($msg, self::LEVEL_ERROR, $type); } public function profileBegin($msg, $type = 'wind.core') { $this->log('begin:' . trim($msg), self::LEVEL_PROFILE, $type); } public function profileEnd($msg, $type = 'wind.core') { $this->log('end:' . trim($msg), self::LEVEL_PROFILE, $type); } public function log($msg, $level = self::LEVEL_INFO, $type = 'wind.system') { if ($this->_writeType == self::WRITE_TYPE) (count($this->_types) >= 5 || $this->_logCount >= $this->_autoFlush) && $this->flush(); else $this->_logCount >= $this->_autoFlush && $this->flush(); if ($level === self::LEVEL_PROFILE) $message = $this->_build($msg, $level, $type, microtime(true), $this->getMemoryUsage(false)); elseif ($level === self::LEVEL_DEBUG) $message = $this->_build($msg, $level, $type, microtime(true)); else $message = $this->_build($msg, $level, $type); $this->_logs[] = array($level, $type, $message); $this->_logCount++; if ($this->_writeType == self::WRITE_TYPE && !in_array($type, $this->_types)) { $this->_types[] = $type; } } public function flush() { if (empty($this->_logs)) return false; Wind::import('WIND:component.utility.WindFile'); $_l = array(); if ($this->_writeType == self::WRITE_LEVEL) { $_logs = array(); foreach ($this->_logs as $key => $value) { $_l[] = $value[2]; $_logs[$value[0]][] = $value[2]; } foreach ($_logs as $key => $value) { switch ($key) { case self::LEVEL_INFO: $key = 'info'; break; case self::LEVEL_ERROR: $key = 'error'; break; case self::LEVEL_DEBUG: $key = 'debug'; break; case self::LEVEL_TRACE: $key = 'trace'; break; case self::LEVEL_PROFILE: $key = 'profile'; break; default: $key = 'all'; break; } if (!$fileName = $this->_getFileName($key)) continue; WindFile::write($fileName, join("", $value), 'a'); } } elseif ($this->_writeType == self::WRITE_TYPE) { $_logs = array(); foreach ($this->_logs as $key => $value) { $_l[] = $value[2]; $_logs[$value[1]][] = $value[2]; } foreach ($_logs as $key => $value) { if (!$fileName = $this->_getFileName($key)) continue; WindFile::write($fileName, join("", $value), 'a'); } } if ($fileName = $this->_getFileName()) { WindFile::write($fileName, join("", $_l), 'a'); } $this->_logs = array(); $this->_logCount = 0; return true; } public function getMemoryUsage($peak = true) { if ($peak && function_exists('memory_get_peak_usage')) return memory_get_peak_usage(); elseif (function_exists('memory_get_usage')) return memory_get_usage(); $pid = getmypid(); if (strncmp(PHP_OS, 'WIN', 3) === 0) { exec('tasklist /FI "PID eq ' . $pid . '" /FO LIST', $output); return isset($output[5]) ? preg_replace('/[\D]/', '', $output[5]) * 1024 : 0; } else { exec("ps -eo%mem,rss,pid | grep $pid", $output); $output = explode("  ", $output[0]); return isset($output[1]) ? $output[1] * 1024 : 0; } } private function _build($msg, $level, $type, $timer = 0, $mem = 0) { $msg = stripslashes(str_replace(array("<br/>", "\r\n", "<br>"), "", trim($msg))); $result = ''; switch ($level) { case self::LEVEL_INFO: $msg .= "\t(" . $type . ")"; $result = $this->_buildInfo($msg); break; case self::LEVEL_ERROR: $msg .= "\t(" . $type . ")"; $result = $this->_buildError($msg); break; case self::LEVEL_DEBUG: $msg .= "\t(" . $type . " timer: " . sprintf('%0.5f', ($timer - DEBUG_TIME)) . ")\r\n"; $result = $this->_buildDebug($msg); break; case self::LEVEL_TRACE: $msg .= "\t(" . $type . ")"; $result = $this->_buildTrace($msg); break; case self::LEVEL_PROFILE: $result = $this->_buildProfile($msg, $type, $timer, $mem); break; default: break; } return $result ? '[' . date('Y-m-d H:i:s') . '] ' . $result . "\r\n" : ''; } private function _buildProfile($msg, $type, $timer, $mem) { $_msg = ''; if (strncasecmp($msg, self::TOKEN_BEGIN, strlen(self::TOKEN_BEGIN)) == 0) { $_token = substr($msg, strlen(self::TOKEN_BEGIN)); $_token = substr($_token, 0, strpos($_token, ':')); $this->_profiles[] = array($_token, substr($msg, strpos($msg, ':', strlen(self::TOKEN_BEGIN)) + 1), $type, $timer, $mem); } elseif (strncasecmp(self::TOKEN_END, $msg, strlen(self::TOKEN_END)) == 0) { $_msg = "PROFILE! Message: \r\n"; $_token = substr($msg, strlen(self::TOKEN_END)); $_token = substr($_token, 0, strpos($_token, ':')); foreach ($this->_profiles as $key => $profile) { if ($profile[0] !== $_token) continue; if ($profile[1]) $_msg .= $profile[1] . "\r\n"; else $_msg .= substr($msg, strpos($msg, ':', strlen(self::TOKEN_END)) + 1) . "\r\n"; $_msg .= "(type: $profile[2] time: " . ($timer - $profile[3]) . " mem: " . ($mem - $profile[4]) . ")"; break; } unset($this->_profiles[$key]); } return $_msg; } private function _buildInfo($msg) { return "INFO! Message:  " . $msg; } private function _buildTrace($msg) { return "TRACE! Message:  " . $msg . implode("\r\n", $this->_getTrace()); } private function _buildDebug($msg) { return 'DEBUG! Message:  ' . $msg . implode("\r\n", $this->_getTrace()); } private function _buildError($msg) { return 'ERROR! Message:  ' . $msg; } private function _getTrace() { $num = 0; $info[] = 'Stack trace:'; $traces = debug_backtrace(); foreach ($traces as $traceKey => $trace) { if ($num >= 7) break; if ((isset($trace['class']) && $trace['class'] == __CLASS__) || isset($trace['file']) && strrpos($trace['file'], __CLASS__ . '.php') !== false) continue; $file = isset($trace['file']) ? $trace['file'] . '(' . $trace['line'] . '): ' : '[internal function]: '; $function = isset($trace['class']) ? $trace['class'] . $trace['type'] . $trace['function'] : $trace['function']; if ($function == 'WindBase::log') continue; $args = array_map(array($this, '_buildArg'), $trace['args']); $info[] = '#' . ($num++) . ' ' . $file . $function . '(' . implode(',', $args) . ')'; } return $info; } private function _buildArg($arg) { switch (gettype($arg)) { case 'array': return 'Array'; break; case 'object': return 'Object ' . get_class($arg); break; default: return "'" . $arg . "'"; break; } } private function _getFileName($suffix = '') { $_maxsize = ($this->_maxFileSize ? $this->_maxFileSize : 100) * 1024; $_logfile = $this->_logDir . '/log' . ($suffix ? '_' . $suffix : '') . '.txt'; if (is_file($_logfile) && $_maxsize <= filesize($_logfile)) { $counter = 0; do { $counter++; $_newFile = $_logfile . '_' . date("Y_m_d_{$counter}"); } while (is_file($_newFile)); @rename($_logfile, $_newFile); } return $_logfile; } public function __destruct() { $this->flush(); } public function setLogDir($logDir) { $this->_logDir = $logDir; } public function setMaxFileSize($maxFileSize) { $this->_maxFileSize = (int) $maxFileSize; } }    class WindException extends Exception { const ERROR_SYSTEM_ERROR = '0'; const ERROR_CLASS_NOT_EXIST = '100'; const ERROR_CLASS_TYPE_ERROR = '101'; const ERROR_CLASS_METHOD_NOT_EXIST = '102'; const ERROR_OBJECT_NOT_EXIST = '103'; const ERROR_PARAMETER_TYPE_ERROR = '110'; const ERROR_CONFIG_ERROR = '120'; const ERROR_RETURN_TYPE_ERROR = '130'; private $innerException = null; public function __construct($message = '', $code = 0, Exception $innerException = null) { $message = $this->buildMessage($message, $code); parent::__construct($message, $code); $this->innerException = $innerException; } public function getInnerException() { return $this->innerException; } public function getStackTrace() { if ($this->innerException) { $thisTrace = $this->getTrace(); $class = __CLASS__; $innerTrace = $this->innerException instanceof $class ? $this->innerException->getStackTrace() : $this->innerException->getTrace(); foreach ($innerTrace as $trace) $thisTrace[] = $trace; return $thisTrace; } else { return $this->getTrace(); } return array(); } public function buildMessage($message, $code) { $message = str_replace(array("<br />", "<br>", "\r\n"), '', $message); eval('$message="' . addcslashes($this->messageMapper($code), '"') . '";'); return $message; } protected function messageMapper($code) { $messages = array(self::ERROR_SYSTEM_ERROR => 'System error \'$message\'.', self::ERROR_CLASS_TYPE_ERROR => 'Incorrect class type \'$message\'.', self::ERROR_CLASS_NOT_EXIST => 'Unable to create instance for \'$message\' , class is not exist.', self::ERROR_CLASS_METHOD_NOT_EXIST => 'Unable to access the method \'$message\' in current class , the method is not exist or is protected.', self::ERROR_OBJECT_NOT_EXIST => 'Unable to access the object in current class \'$message\' ', self::ERROR_CONFIG_ERROR => 'Incorrect config. the config about \'$message\' error.', self::ERROR_PARAMETER_TYPE_ERROR => 'Incorrect parameter type \'$message\'.', self::ERROR_RETURN_TYPE_ERROR => 'Incorrect return type for \'$message\'.'); return isset($messages[$code]) ? $messages[$code] : '$message'; } }   class WindActionException extends WindException { private $error; public function __construct($error, $code = 0) { $this->setError($error); parent::__construct($error->getError(0), $code); } protected function messageMapper($code) { $messages = array(); return isset($messages[$code]) ? $messages[$code] : '$message'; } public function getError() { return $this->error; } public function setError($error) { $this->error = $error; } }    class WindFinalException extends WindException {}    interface IWindFactory { public function getInstance($classAlias); public function getPrototype($classAlias); static public function createInstance($className, $args = array()); }   class WindClassProxy { const EVENT_TYPE_METHOD = 'method'; const EVENT_TYPE_SETTER = 'setter'; const EVENT_TYPE_GETTER = 'getter'; private $_interceptorChain = 'WIND:core.filter.WindHandlerInterceptorChain'; private $_interceptorChainObj = null; protected $_attributes = array(); protected $_className = ''; protected $_classPath = ''; protected $_reflection = null; protected $_instance = null; protected $_listener = array(); public function __construct($targetObject = null) { $targetObject && $this->registerTargetObject($targetObject); } public function registerEventListener($event, $listener, $type = self::EVENT_TYPE_METHOD) { if (!in_array($type, array(self::EVENT_TYPE_METHOD, self::EVENT_TYPE_GETTER, self::EVENT_TYPE_SETTER))) { throw new WindException( '[core.factory.proxy.WindClassProxy.registerEventListener] Unsupport event type:' . $type, WindException::ERROR_PARAMETER_TYPE_ERROR); } !isset($this->_listener[$type][$event]) && $this->_listener[$type][$event] = array(); array_push($this->_listener[$type][$event], $listener); } public function registerTargetObject($targetObject) { if ($this->_instance !== null || !is_object($targetObject)) return; $this->_setClassName(get_class($targetObject)); $this->_instance = $targetObject; $types = array(self::EVENT_TYPE_METHOD, self::EVENT_TYPE_GETTER, self::EVENT_TYPE_SETTER); foreach ($types as $type) $this->_listener[$type] = array(); return $this; } public function __set($propertyName, $value) { $property = $this->_getReflection()->getProperty($propertyName); if (!$property || !$property->isPublic()) { throw new WindException('undefined property name. '); } $listeners = $this->_getListenerByType(self::EVENT_TYPE_SETTER, $propertyName); if (empty($listeners)) return call_user_func_array(array($this, '_setProperty'), array($propertyName, $value)); $interceptorChain = $this->_getInterceptorChain($propertyName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this, '_setProperty'), array($propertyName, $value)); return $interceptorChain->getHandler()->handle($value); } public function __get($propertyName) { $property = $this->_getReflection()->getProperty($propertyName); if (!$property || !$property->isPublic()) { throw new WindException('undefined property name. '); } $listeners = $this->_getListenerByType(self::EVENT_TYPE_GETTER, $propertyName); if (empty($listeners)) return call_user_func_array(array($this, '_getProperty'), array($propertyName)); $interceptorChain = $this->_getInterceptorChain($propertyName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this, '_getProperty'), array($propertyName)); return $interceptorChain->getHandler()->handle($propertyName); } public function __call($methodName, $args) { $listeners = $this->_getListenerByType(self::EVENT_TYPE_METHOD, $methodName); if (empty($listeners)) return call_user_func_array(array($this->_getInstance(), $methodName), (array) $args); $interceptorChain = $this->_getInterceptorChain($methodName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this->_getInstance(), $methodName), $args); return call_user_func_array(array($interceptorChain->getHandler(), 'handle'), (array) $args); } private function _getInterceptorChain($event = '') { if (null === $this->_interceptorChainObj) { $chain = Wind::import($this->_interceptorChain); $interceptorChain = WindFactory::createInstance($chain); if ($interceptorChain && $interceptorChain instanceof WindHandlerInterceptorChain) { $this->_interceptorChainObj = $interceptorChain; } else throw new WindException( '[core.factory.proxy.WindClassProxy._getInterceptorChain] Unable to create interceptorChain.'); } $this->_interceptorChainObj->reset(); return $this->_interceptorChainObj; } private function _getListenerByType($type, $subType) { $listener = array(); if (isset($this->_listener[$type]) && isset($this->_listener[$type][$subType])) { $listener = $this->_listener[$type][$subType]; } return $listener; } public function _getInstance() { return $this->_instance; } public function _getClassName() { return $this->_className; } public function _getClassPath() { return $this->_classPath; } public function _setClassName($className) { $this->_className = $className; } public function _setClassPath($classPath) { $this->_setClassName(Wind::import($classPath)); $this->_classPath = $classPath; } public function _setProperty($propertyName, $value) { $this->_getInstance()->$propertyName = $value; } public function _getProperty($propertyName) { return $this->_getInstance()->$propertyName; } }   Wind::import('COM:utility.WindUtility'); class WindFactory implements IWindFactory { protected $proxyType = 'WIND:core.factory.WindClassProxy'; protected $classDefinitions = array(); protected $instances = array(); protected $prototype = array(); public function __construct($classDefinitions = array()) { if (is_array($classDefinitions)) { $this->classDefinitions = $classDefinitions; } } public function getInstance($alias, $args = array()) { if (isset($this->prototype[$alias])) return clone $this->prototype[$alias]; if (isset($this->instances[$alias])) return $this->instances[$alias]; if (!isset($this->classDefinitions[$alias]) || !($definition = $this->classDefinitions[$alias])) return null; if (!isset($definition['className'])) $definition['className'] = Wind::import(@$definition['path']); if (isset($definition['constructorArgs'])) foreach ((array) $definition['constructorArgs'] as $_var) { if (isset($_var['value'])) { $args[] = $_var['value']; } elseif (isset($_var['ref'])) $args[] = $this->getInstance($_var['ref']); } $instance = $this->createInstance($definition['className'], $args); if (isset($definition['config'])) $this->resolveConfig($definition['config'], $alias, $instance); if (isset($definition['properties'])) $this->buildProperties($definition['properties'], $instance); if (isset($definition['initMethod'])) $this->executeInitMethod($definition['initMethod'], $instance); if (isset($definition['proxy'])) $instance = $this->setProxyForClass($definition['proxy'], $instance); $this->setScope($alias, $definition['scope'], $instance); return $instance; } public function registInstance($instance, $alias, $scope = 'singleton') { if (!is_object($instance) || !$alias) return false; return $this->setScope($alias, $scope, $instance); } static public function createInstance($className, $args = array()) { try { if (IS_DEBUG && IS_DEBUG <= WindLogger::LEVEL_DEBUG) { Wind::log('[core.factory.WindFactory.createInstance] create instance:' . $className, WindLogger::LEVEL_DEBUG, 'core.factory'); } if (empty($args)) { return new $className(); } else { $reflection = new ReflectionClass($className); return call_user_func_array(array($reflection, 'newInstance'), (array) $args); } } catch (Exception $e) { throw new WindException($className, WindException::ERROR_CLASS_NOT_EXIST); } } public function getPrototype($alias) { return isset($this->prototype[$alias]) ? clone $this->prototype[$alias] : null; } public function addClassDefinitions($alias, $classDefinition) { if (!is_string($alias) || empty($alias)) { throw new WindException( '[core.factory.WindFactory.addClassDefinitions] class alias is empty.', WindException::ERROR_PARAMETER_TYPE_ERROR); } if (isset($this->classDefinitions[$alias])) return; $this->classDefinitions[$alias] = $classDefinition; } public function loadClassDefinitions($classDefinitions, $merge = true) { foreach ((array) $classDefinitions as $alias => $definition) { if (!is_array($definition)) continue; if (!isset($this->classDefinitions[$alias]) || $merge === false) { $this->classDefinitions[$alias] = $definition; continue; } $this->classDefinitions[$alias] = WindUtility::mergeArray( $this->classDefinitions[$alias], $definition); unset($this->instances[$alias], $this->prototype[$alias]); } } public function checkAlias($alias) { if (isset($this->prototype[$alias])) return true; elseif (isset($this->instances[$alias])) return true; return false; } protected function setScope($alias, $scope, $instance) { switch ($scope) { case 'prototype': $this->prototype[$alias] = clone $instance; break; case 'application': $this->instances[$alias] = $instance; break; default: $this->instances[$alias] = $instance; break; } return true; } protected function resolveConfig($config, $alias, $instance) { if (isset($config['resource'])) { $_configPath = Wind::getRealPath($config['resource'], true); $configParser = $this->getInstance('configParser'); $config = $configParser->parse($_configPath, $alias, true, $this->getInstance('windCache')); } if ($config && method_exists($instance, 'setConfig')) $instance->setConfig($config); } protected function executeInitMethod($initMethod, $instance) { try { return call_user_func_array(array($instance, $initMethod), array()); } catch (Exception $e) { throw new WindException( '[core.factory.WindFactory.executeInitMethod] (' . $initMethod . ', ' . $e->getMessage() . ')', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } } protected function setProxyForClass($proxy, $instance) { if ($proxy === 'false' || $proxy === false) return $instance; if ($proxy === 'true' || $proxy === true) $proxy = $this->proxyType; $this->addClassDefinitions($proxy, array('path' => $proxy, 'scope' => 'prototype')); return $this->getInstance($proxy)->registerTargetObject($instance); } protected function buildProperties($properties, $instance) { if (!isset($properties['delay'])) { $instance->setDelayAttributes($properties); } elseif ($properties['delay'] === 'false' || $properties['delay'] === false) { foreach ($properties as $key => $subDefinition) { $_value = ''; if (isset($subDefinition['value'])) $_value = $subDefinition['value']; elseif (isset($subDefinition['ref'])) $_value = $this->getInstance($subDefinition['ref']); elseif (isset($subDefinition['path'])) { $_className = Wind::import($subDefinition['path']); $_value = $this->createInstance($_className); } $_setter = 'set' . ucfirst(trim($key, '_')); if (method_exists($instance, $_setter)) call_user_func_array(array($instance, $_setter), array($_value)); } } else $instance->setDelayAttributes($properties); } }   class WindHandlerInterceptor extends WindModule { protected $result = null; protected $interceptorChain = null; public function preHandle() {} public function postHandle() {} public function handle() { $args = func_get_args(); $this->result = call_user_func_array(array($this, 'preHandle'), $args); if ($this->result !== null) { return $this->result; } if (null !== ($handler = $this->interceptorChain->getHandler())) { $this->result = call_user_func_array(array($handler, 'handle'), $args); } else { $this->result = $this->interceptorChain->execute(); } call_user_func_array(array($this, 'postHandle'), $args); return $this->result; } public function setHandlerInterceptorChain($interceptorChain) { $this->interceptorChain = $interceptorChain; } }   Wind::import('COM:fitler.WindHandlerInterceptor'); class WindFilter extends WindHandlerInterceptor { public function preHandle() { } public function postHandle() { } }   class WindHandlerInterceptorChain extends WindModule { protected $_interceptors = array(); protected $_callBack = null; protected $_args = array(); protected $_state = 0; public function setCallBack($callBack, $args = array()) { $this->_callBack = $callBack; $this->_args = $args; } public function execute() { if ($this->_callBack === null) return null; if (is_string($this->_callBack) && !function_exists($this->_callBack)) { throw new WindException( '[core.filter.WindHandlerInterceptorChain.execute]' . $this->_callBack, WindException::ERROR_FUNCTION_NOT_EXIST); } return call_user_func_array($this->_callBack, (array) $this->_args); } public function getHandler() { if (count($this->_interceptors) <= 0) { $this->addInterceptors(new WindHandlerInterceptor()); } if ($this->_state >= count($this->_interceptors)) return null; $handler = $this->_interceptors[$this->_state++]; if ($handler instanceof WindHandlerInterceptor) { $handler->setHandlerInterceptorChain($this); return $handler; } return $this->getHandler(); } public function addInterceptors($interceptors) { if (is_array($interceptors)) $this->_interceptors += $interceptors; else $this->_interceptors[] = $interceptors; } public function reset() { $this->_interceptors = array(); $this->_callBack = null; $this->_args = array(); $this->_state = 0; return true; } }    class WindFilterChain extends WindHandlerInterceptorChain { public function __construct($filterConfig) { $this->_initFilters($filterConfig); } public function deleteFilter($alias) { unset($this->_interceptors[$alias]); } public function addFilter($filter, $beforFilter = '') { if ($beforFilter === '') { $this->addInterceptors(array(get_class($filter) => $filter)); return true; } $_interceptors = array(); foreach ($this->_interceptors as $key => $interceptor) { if ($beforFilter === $key) break; $_interceptors[$key] = $interceptor; unset($this->_interceptors[$key]); } $_interceptors[get_class($filter)] = $filter; $this->_interceptors = (array) $_interceptors + (array) $this->_interceptors; } private function _initFilters($filters = array()) { $_temp = array(); foreach ((array) $filters as $key => $filter) { if (!is_array($filter)) continue; $filterClass = Wind::import($filter[WindSystemConfig::CLASS_PATH]); if (!class_exists($filterClass)) continue; $_temp[$key] = new $filterClass(); } $this->addInterceptors($_temp); } }   interface IWindApplication { public function run(); public function getRequest(); public function getResponse(); public function getWindFactory(); }    class WindUrlFilter extends WindFilter { public function preHandle($request = null, $response = null) { } public function postHandle($request = null, $response = null) { } }    class WindFormListener extends WindHandlerInterceptor { private $request = null; private $formPath = ''; private $errorMessage = null; public function __construct($request, $formPath, $errorMessage) { $this->request = $request; $this->formPath = $formPath; $this->errorMessage = $errorMessage; } public function preHandle() { $className = Wind::import($this->formPath); if (!class_exists($className)) throw new WindException('the form \'' . $this->formPath . '\' is not exists!'); if ('WindEnableValidateModule' != get_parent_class($className)) throw new WindException( 'the form \'' . $this->formPath . '\' is not extends \'WindEnableValidateModule\'!'); $form = new $className(); $methods = get_class_methods($form); foreach ($methods as $method) { if ((0 !== strpos($method, 'set')) || ('' == ($_tmp = substr($method, 3)))) continue; $_tmp[0] = strtolower($_tmp[0]); $value = $this->request->getPost($_tmp) ? $this->request->getPost($_tmp) : $this->request->getGet( $_tmp); if (null === $value) continue; call_user_func_array(array($form, $method), array($value)); } call_user_func_array(array($form, 'validate'), array($form)); if (($error = $form->getErrors())) { list($errorController, $errorAction) = $form->getErrorControllerAndAction(); $this->sendError($errorController, $errorAction, $error); } $this->request->setAttribute('formData', $form); } private function sendError($errorController, $errorAction, $errors) { if (!$this->errorMessage instanceof WindErrorMessage) $this->errorMessage = new WindErrorMessage(); $this->errorMessage->setErrorController($errorController); $this->errorMessage->setErrorAction($errorAction); $this->errorMessage->addError($errors); $this->errorMessage->sendError(); } public function postHandle() { } }   Wind::import('COM:fitler.WindHandlerInterceptor'); class WindLoggerListener extends WindHandlerInterceptor { public function __construct($request) { $this->request = $request; } public function preHandle() { $logger = $this->getLogger(); if ($logger instanceof WindLogger) { $logger->info($this->getPreLogMessage(func_get_args())); } } public function postHandle() { $logger = $this->getLogger(); if ($logger instanceof WindLogger) { $logger->info($this->getPostLogMessage(func_get_args())); } } private function getLogger() { if (!isset($this->logger)) { $factory = $this->request->getAttribute(WindFrontController::WIND_FACTORY); $this->logger = $factory->getInstance(COMPONENT_LOGGER); } return $this->logger; } private function getPreLogMessage($args) { $log = $this->getLogMessage($args); $log['caller'] = ' #[caller]: ' . $log['caller']; $log['excute'] = ' #[excute-begin]: ' . $log['excute']; $message = 'Begin ' . $this->event[0] . '->' . $this->event[1]; return "{$message}<br/>" . implode("\r\n", $log) . '<br/>'; } private function getPostLogMessage($args) { $log = $this->getLogMessage($args); $log['caller'] = ' #[caller]: ' . $log['caller']; $log['excute'] = ' #[excute-end]: ' . $log['excute']; $log['output'] = ' #[output]: ' . $this->buildArg($this->result); $message = 'End ' . $this->event[0] . '->' . $this->event[1]; return "{$message}<br/>" . implode("\r\n", $log) . '<br/>'; } private function getLogMessage($args) { $method = ''; $info = array(); $flag = false; foreach (debug_backtrace(false) as $traceKey => $trace) { $class = isset($trace['class']) ? $trace['class'] : ''; if (in_array($class, array('', 'WindLogger', __CLASS__, 'WindHandlerInterceptor'))) continue; $function = isset($trace['function']) ? $trace['function'] : ''; ($class == 'WindClassProxy' && $function == '__call') && $method = trim( $trace['args'][0]); ($function == $method) && $flag = true; if (!isset($trace['file'])) continue; $info['caller'] = addslashes($trace['file']) . '(' . $trace['line'] . '): '; break; } list($class, $method) = $this->event; $args = array_map(array($this, 'buildArg'), $args); $info['excute'] = $class . '->' . $method . '(' . implode(', ', $args) . ')'; return $info; } private function buildArg($arg) { switch (gettype($arg)) { case 'array': return 'Array'; break; case 'object': return 'Object ' . get_class($arg); break; default: return "'" . $arg . "'"; break; } } }   Wind::import('COM:fitler.WindHandlerInterceptor'); class WindValidateListener extends WindHandlerInterceptor { private $request = null; private $validateRules = array(); private $validator = null; private $validatorClass = ''; private $defaultMessage = '验证失败'; public function __construct($request, $validateRules, $validatorClass) { $this->request = $request; $this->validateRules = (array) $validateRules; $this->validatorClass = $validatorClass; } public function preHandle() { if (!isset($this->validateRules['errorMessage'])) $errorMessage = new WindErrorMessage(); else { $errorMessage = $this->validateRules['errorMessage']; unset($this->validateRules['errorMessage']); } $_input = new stdClass(); foreach ((array) $this->validateRules as $rule) { if (!is_array($rule)) continue; $key = $rule['field']; $value = $this->request->getGet($key) ? $this->request->getGet($key) : $this->request->getPost( $key); $args = $rule['args']; array_unshift($args, $value); if (call_user_func_array(array($this->getValidator(), $rule['validator']), (array) $args) === false) { if (null === $rule['default']) $errorMessage->addError( ($rule['message'] ? $rule['message'] : $this->defaultMessage), $key); else $value = $rule['default']; } $this->request->setAttribute($key, $value); $_input->$key = $value; } if ($errorMessage->getError()) $errorMessage->sendError(); else $this->request->setAttribute('inputData', $_input); } private function getValidator() { if ($this->validator === null) { $_className = Wind::import($this->validatorClass); $this->validator = WindFactory::createInstance($_className); if ($this->validator === null) throw new WindException('validator', WindException::ERROR_RETURN_TYPE_ERROR); } return $this->validator; } public function postHandle() { } }    abstract class WindSimpleController extends WindModule implements IWindController { protected $forward = null; protected $errorMessage = null; abstract public function run(); protected function beforeAction($handlerAdapter) {} protected function afterAction($handlerAdapter) {} public function preAction($handlerAdapter) { $this->urlHelper = null; $this->errorMessage = null; $this->forward = null; } public function postAction($handlerAdapter) {} public function doAction($handlerAdapter) { $this->beforeAction($handlerAdapter); $this->setDefaultTemplateName($handlerAdapter); $method = $this->resolvedActionMethod($handlerAdapter); call_user_func_array(array($this, $method), array()); if ($this->errorMessage !== null) $this->getErrorMessage()->sendError(); $this->afterAction($handlerAdapter); return $this->forward; } protected function forwardAction($action = 'run', $controller = '', $args = array(), $isRedirect = false) { $this->getForward()->forwardAnotherAction($action, $controller, $args, $isRedirect); } protected function forwardRedirect($url) { $this->getForward()->setIsRedirect(true); $this->getForward()->setUrl($url); } protected function setOutput($data, $key = '') { $this->getForward()->setVars($data, $key); } protected function setGlobal($data, $key = '') { $this->getResponse()->setData($data, $key, true); } protected function getInput($name, $type = '', $callback = null) { if (is_array($name)) return $this->getInputWithArray($name, $type); else return $this->getInputWithString($name, $type, $callback); } protected function setTemplate($template) { $this->getForward()->setTemplateName($template); } protected function setTemplatePath($templatePath) { $this->getForward()->setTemplatePath($templatePath); } protected function setTemplateExt($templateExt) { $this->getForward()->setTemplateExt($templateExt); } protected function setLayout($layout) { $this->getForward()->setLayout($layout); } protected function addMessage($message, $key = '') { $this->getErrorMessage()->addError($message, $key); } protected function showMessage($message = '', $key = '', $errorAction = '') { $this->addMessage($message, $key); $this->getErrorMessage()->setErrorAction($errorAction); $this->getErrorMessage()->sendError(); } protected function setDefaultTemplateName($handlerAdapter) {} protected function resolvedActionMethod($handlerAdapter) { return 'run'; } private function getInputWithString($name, $type = '', $callback = array()) { $value = ''; switch (strtolower($type)) { case 'form': $value = $this->response->getData($name); break; case IWindRequest::INPUT_TYPE_GET: $value = $this->request->getGet($name); break; case IWindRequest::INPUT_TYPE_POST: $value = $this->request->getPost($name); break; case IWindRequest::INPUT_TYPE_COOKIE: $value = $this->request->getCookie($name); break; default: $value = $this->request->getAttribute($name); } return $callback ? array($value, call_user_func_array($callback, array($value))) : $value; } private function getInputWithArray($name, $type = '') { $result = array(); foreach ($name as $key => $value) { $result[(is_array($value) ? $key : $value)] = $this->getInput($value, $type); } return $result; } protected function getForward() { return $this->_getForward(); } protected function getErrorMessage() { return $this->_getErrorMessage(); } } interface IWindController { public function doAction($handlerAdapter); public function preAction($handlerAdapter); public function postAction($handlerAdapter); }    abstract class WindController extends WindSimpleController { protected $validatorClass = 'WIND:component.utility.WindValidator'; protected $formClass = ''; final public function preAction($handlerAdapter) { parent::preAction($handlerAdapter); if ($formClassPath = $this->getFormClass()) { $this->registerEventListener('doAction', new WindFormListener($this->request, $formClassPath, $this->getErrorMessage())); } elseif ($rules = $this->validatorFormRule($handlerAdapter->getAction())) { if (!isset($rules['errorMessage'])) { $rules['errorMessage'] = $this->getErrorMessage(); } $this->registerEventListener('doAction', new WindValidateListener($this->request, $rules, $this->getValidatorClass())); } return true; } protected function setDefaultTemplateName($handlerAdapter) { } protected function resolvedActionMethod($handlerAdapter) { $action = $handlerAdapter->getAction(); if ($action !== 'run') $action = $this->resolvedActionName($action); if ($action == 'doAction') { throw new WindException('[core.web.WindController.resolvedActionMethod]', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } $method = new ReflectionMethod($this, $action); if ($method->isAbstract() || !$method->isPublic()) { throw new WindException('[core.web.WindController.resolvedActionMethod]', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } return $action; } protected function resolvedActionName($action) { return $action . 'Action'; } protected function validatorFormRule($type) { return array(); } protected function getFormClass() { return $this->formClass; } protected function getValidatorClass() { return $this->validatorClass; } }  Wind::import('COM:viewer.exception.WindViewException'); class WindDispatcher extends WindModule { protected $processCache = array(); protected $display = false; public function dispatch($forward, $router, $display) { $this->checkProcess($router, false); if ($forward->getIsRedirect()) $this->dispatchWithRedirect($forward, $router); elseif ($forward->getIsReAction()) $this->dispatchWithAction($forward, $router, $display); else $this->render($forward, $router); } protected function dispatchWithRedirect($forward, $router) { $_url = $forward->getUrl(); if (!$_url && $forward->getIsReAction()) { $_url = $this->_getUrlHelper()->createUrl($forward->getAction(), $forward->getController(), $forward->getArgs()); $router->reParse(); if (!$this->checkProcess($router)) { throw new WindFinalException( '[core.web.WindDispatcher.dispatchWithRedirect] Duplicate request: ' . $router->getController() . ',' . $router->getAction(), WindException::ERROR_SYSTEM_ERROR); } } else $_url = $this->_getUrlHelper()->checkUrl($_url); $this->getResponse()->sendRedirect($_url); } protected function dispatchWithAction($forward, $router, $display) { if (!$action = $forward->getAction()) throw new WindException('[core.web.WindDispatcher.dispatchWithAction] forward fail.', WindException::ERROR_PARAMETER_TYPE_ERROR); $args = $forward->getArgs(); $this->display = $display; list($action, $_args) = explode('?', $action . '?'); $action = trim($action, '/') . '/'; $action = explode('/', $action); end($action); if ($_tmp = prev($action)) $router->setAction($_tmp); if ($_tmp = prev($action)) $router->setController($_tmp); if ($_tmp = prev($action)) $router->setModule($_tmp); if (!$this->checkProcess($router)) { throw new WindFinalException( '[core.web.WindDispatcher.dispatchWithRedirect] Duplicate request: ' . $router->getController() . ',' . $router->getAction(), WindException::ERROR_SYSTEM_ERROR); } Wind::getApp()->processRequest(); } protected function render($forward, $router) { if ($windViewClass = $forward->getWindView()) { $_className = Wind::import($windViewClass); $view = $this->getSystemFactory()->createInstance($windViewClass); } else $view = $this->getSystemFactory()->getInstance('windView'); $view->render($forward, $router, $this->display); $this->display = false; } protected function checkProcess($router, $check = true) { if ($check === false) { $this->processCache['action'] = $router->getAction(); $this->processCache['controller'] = $router->getController(); $this->processCache['module'] = $router->getModule(); } elseif ($router->getAction() === @$this->processCache['action'] && $router->getController() === @$this->processCache['controller'] && $router->getModule() === @$this->processCache['module']) return false; return true; } }    class WindErrorHandler extends WindController { protected $error = array(); protected $errorCode = 0; protected $urlReferer = ''; public function beforeAction($handlerAdapter) { $this->error = $this->getInput('error'); $this->errorCode = (int) $this->getInput('errorCode'); if ($this->request->getUrlReferer()) $this->urlReferer = $this->getRequest()->getUrlReferer(); else $this->urlReferer = $this->getRequest()->getBaseUrl(); } public function run() { if ($this->errorCode >= 400 && $this->errorCode <= 505) { $_statusMsg = ucwords($this->getResponse()->codeMap($this->errorCode)); $topic = "$this->errorCode - " . $_statusMsg; $this->getResponse()->setStatus($this->errorCode); } else $topic = "Error message"; $this->setOutput($topic, "errorHeader"); $this->setOutput($this->urlReferer, "baseUrl"); $this->setOutput($this->error, "errors"); $this->setTemplatePath('COM:viewer.errorPage'); $this->setTemplate('default_error'); } }   class WindForward extends WindModule { private $windView; private $templateName; private $templatePath = null; private $templateExt = null; private $layout; private $vars = array(); private $isReAction = false; private $isRedirect = false; private $url; private $action; private $controller; private $args; public function forwardAnotherAction($action = 'run', $controller = '', $args = array(), $isRedirect = false) { $this->setIsReAction(true); $this->setAction($action); $this->setController($controller); $this->setArgs($args); $this->setIsRedirect($isRedirect); } public function forwardAction($action, $args = array(), $isRedirect = false) { $this->setIsReAction(true); $this->setAction($action); $this->setArgs($args); $this->setIsRedirect($isRedirect); } public function setVars($vars, $key = '') { if (!$key) { if (is_object($vars)) $vars = get_object_vars($vars); if (is_array($vars)) $this->vars += $vars; } else $this->vars[$key] = $vars; return; } public function getIsRedirect() { return $this->isRedirect; } public function setIsRedirect($isRedirect) { $this->isRedirect = $isRedirect; } public function getIsReAction() { return $this->isReAction; } public function setIsReAction($isReAction) { $this->isReAction = $isReAction; } public function getVars() { return $this->vars; } public function getUrl() { return $this->url; } public function setUrl($url) { $this->url = $url; } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function getArgs() { return $this->args; } public function setAction($action) { $this->action = $action; } public function setController($controller) { $this->controller = $controller; } public function setArgs($args) { $this->args = $args; } public function getTemplateName() { return $this->templateName; } public function getTemplatePath() { return $this->templatePath; } public function getTemplateExt() { return $this->templateExt; } public function getLayout() { return $this->layout; } public function setTemplateName($templateName) { $this->templateName = $templateName; } public function setTemplatePath($templatePath) { $this->templatePath = $templatePath; } public function setTemplateExt($templateExt) { $this->templateExt = $templateExt; } public function setLayout($layout) { $this->layout = $layout; } public function getWindView() { return $this->windView; } public function setWindView($windView) { $this->windView = $windView; } }   class WindSystemConfig extends WindModule { private $appName = ''; private $modules = array(); public function __construct($config, $appName, $factory) { $this->appName = $appName; $this->setConfig($config, $factory); } public function setConfig($config, $factory = null) { if (empty($config)) return; if (is_string($config)) { $configParser = $factory->getInstance('configParser'); $config = $configParser->parse($config); if (isset($config[$this->appName])) $this->_config = $config[$this->appName]; } else $this->_config = $this->_config ? array_merge($this->_config, $config) : (array) $config; } public function getAppName() { return $this->appName; } public function getAppClass($default = '') { return $this->getConfig('class', '', $default); } public function getCharset() { return $this->getConfig('charset', '', 'utf-8'); } public function getFilters() { return $this->getConfig('filters'); } public function getFilterClass() { return $this->getConfig('filters', 'class'); } public function getRouter() { return $this->getConfig('router'); } public function getRouterClass() { return $this->getConfig('router', 'class', COMPONENT_ROUTER); } public function getModules($name = '') { return $this->getConfig('modules', $name, array()); } public function setModules($name, $config = array()) { if (!$_default = @$this->_config['modules']['default']) { $_default = $this->getDefaultConfigStruct('modules'); $this->_config['modules']['default'] = $_default; } if (!$config) $this->_config['modules'][$name] = $_default; else $this->_config['modules'][$name] = WindUtility::mergeArray($_default, $config); return $this->_config['modules'][$name]; } public function getModuleTemplateDir($name, $default = '') { return $this->getConfig('template-dir', '', $default, $this->getModules($name)); } public function getModuleErrorHandler($name, $default = '') { return $this->getConfig('errorhandler', '', $default, $this->getModules($name)); } public function getModuleControllerPath($name, $default = '') { return $this->getConfig('controller-path', '', $default, $this->getModules($name)); } public function getModuleControllerSuffix($name, $default = '') { return $this->getConfig('controller-suffix', '', $default, $this->getModules($name)); } public function getComponents($name = '', $default = array()) { return $this->getConfig('components', $name, $default); } public function getDbConfig($dbName = '') { $config = $this->getConfig('db'); if (isset($config['resource']) && !empty($config['resource'])) { $_resource = Wind::getRealPath($config['resource'], true); $this->_config['db'] = $this->parseConfig($_resource, 'db'); } return $this->getConfig('db', $dbName); } private function parseConfig($config, $key = 'config', $append = true) { if (!$config) return array(); $configParser = $this->getSystemConfig()->getInstance('configParser'); return $configParser->parse($config); } public function getDefaultConfigStruct($configName) { $_tmp = array(); $_tmp['modules']['controller-path'] = $this->getConfig('controller-path', '', 'controller'); $_tmp['modules']['controller-suffix'] = $this->getConfig('controller-suffix', '', 'Controller'); $_tmp['modules']['error-handler'] = $this->getConfig('error-handler', '', 'WIND:core.web.WindErrorHandler'); return $configName ? (isset($_tmp[$configName]) ? $_tmp[$configName] : array()) : array(); } }   class WindUrlHelper extends WindModule { public function createUrl($action, $controller = '', $params = array()) { $router = $this->getSystemFactory()->getInstance(COMPONENT_ROUTER); return $router->buildUrl($action, $controller, $params); } }   Wind::import('COM:http.request.WindHttpRequest'); Wind::import('COM:http.response.WindHttpResponse'); class WindWebApplication extends WindModule implements IWindApplication { private $request; private $response; protected $windFactory = null; protected $dispatcher = null; protected $handlerAdapter = null; protected $filterChain = 'WIND:filter.WindFilterChain'; public function __construct($config, $factory) { $this->request = new WindHttpRequest(); $this->response = $this->request->getResponse(@$config['charset']); $this->windFactory = $factory; $this->setConfig($config); } public function run() { set_error_handler('WindHelper::errorHandle'); set_exception_handler('WindHelper::exceptionHandle'); $this->windFactory->loadClassDefinitions($this->getConfig('components')); $this->_getHandlerAdapter()->route(); if (null == ($filterChain = $this->getFilterChain())) { $this->processRequest(); } else { $filterChain->setCallBack(array($this, 'processRequest')); $filterChain->getHandler()->handle($this->request, $this->response); } restore_error_handler(); restore_exception_handler(); $this->response->sendResponse(); } public function doDispatch($forward, $display = false) { if ($forward === null) return; $moduleName = $this->handlerAdapter->getModule(); if (!($module = $this->getModules($moduleName))) throw new WindActionException( '[core.web.WindWebApplication.doDispatch] Your requested \'' . $moduleName . '\' was not found on this server.', 404); if ($forward->getTemplateExt() === null && isset($module['template-ext'])) $forward->setTemplateExt($module['template-ext']); if ($forward->getTemplatePath() === null && isset($module['template-dir'])) $forward->setTemplatePath($module['template-dir']); $this->_getDispatcher()->dispatch($forward, $this->handlerAdapter, $display); } public function processRequest() { try { $moduleName = $this->handlerAdapter->getModule(); if (!$moduleName) { $moduleName = 'default'; $this->handlerAdapter->setModule($moduleName); $module = $this->setModules($moduleName); } else { if (!($module = $this->getModules($moduleName))) throw new WindActionException( '[core.web.WindWebApplication.processRequest] Your requested \'' . $moduleName . '\' was not found on this server.', 404); $module = $this->setModules($moduleName, $module); } $handlerPath = @$module['controller-path'] . '.' . ucfirst( $this->handlerAdapter->getController()) . @$module['controller-suffix']; $handlerPath = trim($handlerPath, '.'); if (!$handlerPath) throw new WindActionException( '[core.web.WindWebApplication.processRequest] Your requested \'' . $handlerPath . '\' was not found on this server.', 404); strpos($handlerPath, ':') === false && $handlerPath = Wind::getAppName() . ':' . $handlerPath; $this->getSystemFactory()->addClassDefinitions($handlerPath, array('path' => $handlerPath, 'scope' => 'singleton', 'proxy' => true, 'properties' => array('errorMessage' => array('ref' => 'errorMessage'), 'forward' => array('ref' => 'forward'), 'urlHelper' => array('ref' => 'urlHelper')))); $handler = $this->windFactory->getInstance($handlerPath); if (!$handler) throw new WindActionException( '[core.web.WindWebApplication.processRequest] Your requested \'' . $handlerPath . '\' was not found on this server.', 404); $handler->preAction($this->handlerAdapter); $forward = $handler->doAction($this->handlerAdapter); $handler->postAction($this->handlerAdapter); $this->doDispatch($forward); } catch (WindActionException $e) { $this->sendErrorMessage($e); } catch (WindViewException $e) { $this->sendErrorMessage($e); } } protected function sendErrorMessage($exception) { $moduleName = $this->handlerAdapter->getModule(); if ($moduleName === 'error' || !($module = $this->getModules($moduleName))) throw new WindException( '[core.web.WindWebApplication.sendErrorMessage] ' . $exception->getMessage()); if ($exception instanceof WindActionException) $errorMessage = $exception->getError(); if (!$errorMessage) { $errorMessage = $this->windFactory->getInstance('errorMessage'); $errorMessage->addError($exception->getMessage()); } if (!$_errorAction = $errorMessage->getErrorAction()) { preg_match("/([a-zA-Z]*)$/", @$module['error-handler'], $matchs); $_errorHandler = trim(substr(@$module['error-handler'], 0, -(strlen(@$matchs[0])))); $_errorAction = 'error/' . @$matchs[0] . '/run/'; $this->setModules('error', array('controller-path' => $_errorHandler, 'controller-suffix' => '', 'error-handler' => '')); } $forward = $this->getSystemFactory()->getInstance('forward'); $forward->forwardAction($_errorAction); $this->getRequest()->setAttribute($errorMessage->getError(), 'error'); $this->getRequest()->setAttribute($exception->getCode(), 'errorCode'); $this->doDispatch($forward); } protected function getFilterChain() { if (!$filters = $this->getConfig('filters')) return null; $filterChainPath = @$filters['class'] ? $filters['class'] : $this->filterChain; unset($filters['class']); if (empty($filters)) return null; $this->windFactory->addClassDefinitions($filterChainPath, array('path' => $filterChainPath, 'scope' => 'singleton')); return $this->windFactory->getInstance($filterChainPath, array($filters)); } public function setModules($name, $config = array()) { if (isset($this->_config['modules']['default'])) $_default = $this->_config['modules']['default']; else { $_default = array('controller-path' => 'controller', 'controller-suffix' => 'Controller', 'error-handler' => 'WIND:core.web.WindErrorHandler'); $this->_config['modules']['default'] = $_default; } if (!$config) $this->_config['modules'][$name] = $_default; else $this->_config['modules'][$name] = WindUtility::mergeArray($_default, $config); return $this->_config['modules'][$name]; } public function getModules($name = '') { return $this->getConfig('modules', $name, array()); } public function setConfig($config) { if (!$config) return; $config = @$config[Wind::getAppName()] ? $config[Wind::getAppName()] : $config; $this->_config = $config; } public function registeComponent($componentName, $componentInstance, $scope) { return $this->windFactory->registInstance($componentInstance, $componentName); } public function getComponent($componentName) { return $this->windFactory->getInstance($componentName); } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function getWindFactory() { return $this->windFactory; } }   class WindEnableValidateModule extends WindModule { protected $_validatorClass = 'WIND:component.utility.WindValidator'; protected $errorController = ''; protected $errorAction = ''; private $_validator = null; private $_errors = array(); private $_defaultMessage = 'the field validate fail.'; public function getErrors() { return $this->_errors; } public function getErrorControllerAndAction() { return array($this->errorController, $this->errorAction); } protected function validateRules() { return array(); } public function validate(&$input) { if (is_array($input)) $this->validateArray($input); elseif (is_object($input)) $this->validateObject($input); } private function validateArray(&$input) { $rules = $this->validateRules(); foreach ((array) $rules as $rule) { $_input = isset($input[$rule['field']]) ? $input[$rule['field']] : ''; $arg = (array) $rule['args']; array_unshift($arg, $_input); if (call_user_func_array(array($this->getValidator(), $rule['validator']), $arg) !== false) continue; if ($rule['default'] === null) { $this->_errors[$rule['field']] = $rule['message']; continue; } $input[$rule['field']] = $rule['default']; } } private function validateObject(&$input) { $rules = $this->validateRules(); $methods = get_class_methods($input); foreach ((array) $rules as $rule) { $getMethod = 'get' . ucfirst($rule['field']); $_input = in_array($getMethod, $methods) ? call_user_func(array($input, $getMethod)) : ''; $arg = (array) $rule['args']; array_unshift($arg, $_input); if (call_user_func_array(array($this->getValidator(), $rule['validator']), $arg) !== false) continue; if ($rule['default'] === null) { $this->_errors[$rule['field']] = $rule['message']; continue; } $setMethod = 'set' . ucfirst($rule['field']); in_array($setMethod, $methods) && call_user_func_array(array($input, $setMethod), array($rule['default'])); } } protected function setValidator($validator) { $this->_validator = $validator; } protected function getValidator() { if ($this->_validator === null) { $_className = Wind::import($this->_validatorClass); $this->_validator = WindFactory::createInstance($_className); if ($this->_validator === null) throw new WindException('validator', WindException::ERROR_RETURN_TYPE_ERROR); } return $this->_validator; } }   class WindErrorMessage extends WindModule implements IWindErrorMessage { private $error = array(); private $errorAction; public function __construct($message = '', $errorAction = '') { $message !== '' && $this->addError($message); $errorAction !== '' && $this->setErrorAction($errorAction); } public function sendError() { if (empty($this->error)) return; throw new WindActionException($this); } public function clearError() { $this->error = array(); } public function getError($key = '') { if ($key === '') return $this->error; return isset($this->error[$key]) ? $this->error[$key] : ''; } public function addError($error, $key = '') { if ($key === '') { if (is_string($error)) $this->error[] = $error; elseif (is_object($error)) $error = get_object_vars($error); if (is_array($error)) $this->error += $error; } else $this->error[$key] = $error; } public function getErrorAction() { return $this->errorAction; } public function setErrorAction($errorAction) { $this->errorAction = $errorAction; } } interface IWindErrorMessage { public function addError($message, $key = ''); public function getError($key = ''); public function clearError(); public function sendError(); }   class WindHelper { const INTERNAL_LOCATION = "~Internal Location~"; public static function errorHandle($errno, $errstr, $errfile, $errline) { echo $errno,$errfile,'.....',$errline,'<br>'; if ($errno & error_reporting()) { restore_error_handler(); restore_exception_handler(); $trace = debug_backtrace(); unset($trace[0]["function"], $trace[0]["args"]); self::crash(self::getErrorName($errno) . ':' . $errstr, $errfile, $errline, $trace); exit(); } } public static function exceptionHandle($exception) { restore_error_handler(); restore_exception_handler(); $trace = $exception->getTrace(); if (@$trace[0]['file'] == '') { unset($trace[0]); $trace = array_values($trace); } $file = @$trace[0]['file']; $line = @$trace[0]['line']; self::crash($exception->getMessage(), $file, $line, $trace, $exception->getCode()); exit(); } public static function errorInfo() { $info = "The server encountered an internal error and failed to process your request. Please try again later. If this error is temporary, reloading the page might resolve the problem.\nIf you are able to contact the administrator report this error message."; $info .= "(" . Wind::getApp()->getConfig('siteInfo', '', "http://www.windframework.com/") . ")"; return $info; } protected static function crash($message, $file, $line, $trace, $status = 0) { $errmessage = substr($message, 0, 8000) . "\n"; $_headers = Wind::getApp()->getResponse()->getHeaders(); $_errhtml = false; foreach ($_headers as $_header) { if (strtolower($_header['name']) == strtolower('Content-type')) { $_errhtml = strpos(strtolower($_header['value']), strtolower('text/html')) !== false; break; } } $msg = ''; if (IS_DEBUG) { $errtrace = "__Stack:\n"; $count = count($trace); $padLen = strlen($count); foreach ($trace as $key => $call) { if (!isset($call['file']) || $call['file'] == '') { $call['file'] = self::INTERNAL_LOCATION; $call['line'] = 'N/A'; } $traceLine = '#' . str_pad(($count - $key), $padLen, "0", STR_PAD_LEFT) . '  ' . self::getCallLine( $call); $errtrace .= "$traceLine\n"; } $errsample = ''; if ($_errhtml && is_file($file)) { $currentLine = $line - 1; $fileLines = explode("\n", file_get_contents($file, null, null, 0, 10000000)); $topLine = $currentLine - 5; $fileLines = array_slice($fileLines, $topLine > 0 ? $topLine : 0, 10, true); if (($count = count($fileLines)) > 0) { $padLen = strlen($count); foreach ($fileLines as $line => &$fileLine) $fileLine = " " . htmlspecialchars( str_pad($line + 1, $padLen, "0", STR_PAD_LEFT) . ": " . str_replace( "\t", "    ", rtrim($fileLine)), null, "UTF-8"); $fileLines[$currentLine] = "<b style=\"color:red; background:whiteSmoke\">" . $fileLines[$currentLine] . "</b>"; $errsample = implode("\n", $fileLines) . "\n"; } } if ($_errhtml) $errfile = "<b style=\"background:whiteSmoke\">$file</b>"; else $errfile = "$file"; $msg = "$errfile\n$errsample\n$errtrace\n"; } $msg .= self::errorInfo(); if ($status >= 400 && $status <= 505) { $_statusMsg = ucwords(Wind::getApp()->getResponse()->codeMap($status)); $topic = "$status - " . $_statusMsg . "\n"; header('HTTP/1.x ' . $status . ' ' . $_statusMsg); header('Status: ' . $status . ' ' . $_statusMsg); } else $topic = "Wind Framework - Error Caught\n"; if ($_errhtml) { $msg = "<html><head><title>$topic</title></head><body><pre><h3>$topic</h3><b style=\"background:whiteSmoke\">$errmessage</b>\n$msg</pre></body></html>"; } else $msg = "$topic\n$errmessage\n$msg"; ob_end_clean(); die($msg); } private static function getCallLine($call) { $call_signature = ""; if (isset($call['file'])) $call_signature .= $call['file'] . " "; if (isset($call['line'])) $call_signature .= "(" . $call['line'] . ") "; if (isset($call['function'])) { $call_signature .= $call['function'] . '('; if (isset($call['args'])) { foreach ($call['args'] as $arg) { if (is_string($arg)) $arg = '"' . (strlen($arg) <= 64 ? $arg : substr($arg, 0, 64) . "…") . '"'; else if (is_object($arg)) $arg = "[Instance of '" . get_class($arg) . "']"; else if ($arg === true) $arg = "true"; else if ($arg === false) $arg = "false"; else if ($arg === null) $arg = "null"; else $arg = strval($arg); $call_signature .= $arg . ','; } } $call_signature = trim($call_signature, ',') . ")"; } return $call_signature; } protected static function getErrorName($errorNumber) { $errorMap = array(E_ERROR => "E_ERROR", E_WARNING => "E_WARNING", E_PARSE => "E_PARSE", E_NOTICE => "E_NOTICE ", E_CORE_ERROR => "E_CORE_ERROR", E_CORE_WARNING => "E_CORE_WARNING", E_COMPILE_ERROR => "E_COMPILE_ERROR", E_COMPILE_WARNING => "E_COMPILE_WARNING", E_USER_ERROR => "E_USER_ERROR", E_USER_WARNING => "E_USER_WARNING", E_USER_NOTICE => "E_USER_NOTICE", E_STRICT => "E_STRICT", E_RECOVERABLE_ERROR => "E_RECOVERABLE_ERROR", E_ALL => "E_ALL"); return isset($errorMap[$errorNumber]) ? $errorMap[$errorNumber] : 'E_UNKNOWN'; } public static function resolveController($controllerPath) { $_m = $_c = ''; if (!$controllerPath) return array($_c, $_m); if (false !== ($pos = strrpos($controllerPath, '.'))) { $_m = substr($controllerPath, 0, $pos); $_c = substr($controllerPath, $pos + 1); } else { $_c = $controllerPath; } return array($_c, $_m); } }    interface IWindConfigParser { public function parse($configPath, $alias = '', $append = '', AbstractWindCache $cache = null); }  Wind::import('COM:parser.IWindConfigParser'); class WindConfigParser implements IWindConfigParser { const CONFIG_XML = '.XML'; const CONFIG_PHP = '.PHP'; const CONFIG_INI = '.INI'; const CONFIG_PROPERTIES = '.PROPERTIES'; private $configParsers = array(); public function parse($configPath, $alias = '', $append = '', AbstractWindCache $cache = null) { if ($config = $this->getCache($alias, $append, $cache)) return $config; $config = $this->doParser($configPath); $this->setCache($alias, $append, $cache, $config); return $config; } private function setCache($alias, $append, $cache, $data) { if (!$alias || !$cache) return; if ($append) { $_config = (array) $cache->get($append); $_config[$alias] = $data; $cache->set($append, $_config); } else { $cache->set($alias, $data); } } private function getCache($alias, $append, $cache) { if (!$alias || !$cache) return array(); if (!$append) return $cache->get($alias); $config = $cache->get($append); return isset($config[$alias]) ? $config[$alias] : array(); } private function createParser($type) { switch ($type) { case self::CONFIG_XML: Wind::import("WIND:component.parser.WindXmlParser"); return new WindXmlParser(); break; case self::CONFIG_INI: Wind::import("WIND:component.parser.WindIniParser"); return new WindIniParser(); break; case self::CONFIG_PROPERTIES: Wind::import("WIND:component.parser.WindPropertiesParser"); return new WindPropertiesParser(); break; default: throw new WindException('\'ConfigParser\' failed to initialize.'); break; } } private function doParser($configFile) { if (!is_file($configFile)) throw new WindException( '[component.parser.WindConfigParser.doParser] The file \'' . $configFile . '\' is not exists'); $ext = strtoupper(strrchr($configFile, '.')); if ($ext == self::CONFIG_PHP) return @include ($configFile); if (!isset($this->configParsers[$ext])) $this->configParsers[$ext] = $this->createParser($ext); return $this->configParsers[$ext]->parse($configFile); } }   class WindIniParser { protected $separator = '.'; public function parse($filename, $process = true, $build = true) { if (!is_file($filename)) { return array(); } $data = parse_ini_file($filename, $process); return $build ? $this->buildData($data) : $data; } public function buildData(&$data) { foreach ((array)$data as $key => $value) { if (is_array($value)) { $data[$key] = $this->formatDataArray($value); } else { $this->formatDataFromString($key, $value, $data); } } return $data; } public function toArray($key, $value, &$data = array()) { if (empty($key) && empty($value)) return array(); if (strpos($key, $this->separator)) { $start = substr($key, 0, strpos($key, $this->separator)); $end = substr($key, strpos($key, $this->separator) + 1); $data[$start] = array(); $this->toArray($end, $value, $data[$start]); } else { $data[$key] = $value; } return $data; } public function formatDataArray(&$original, &$data = array()) { foreach ((array)$original as $key => $value) { $tmp = $this->toArray($key, $value); foreach ($tmp as $tkey => $tValue) { if (is_array($tValue)) { if (!isset($data[$tkey])) { $data[$tkey] = array(); } $this->formatDataArray($tValue, $data[$tkey]); } else { $data[$tkey] = $tValue; } } } return $data; } public function formatDataFromString($key, $value, &$data) { $tmp = $this->toArray($key, $value); if(false == strpos($key, $this->separator)){ return $tmp; } $start = substr($key, 0, strpos($key, $this->separator)); if ((!isset($data[$start]) || !is_array($data[$start])) && isset($tmp[$start])) { $data[$start] = $tmp[$start]; } else { foreach ($data as $d_key => $d_value) { if (!isset($tmp[$d_key]) || !is_array($tmp[$d_key])) { continue; } foreach ($tmp[$d_key] as $a => $b) { $this->merge($a, $b, $data[$start]); } } } unset($data[$key]); return $data; } private function merge($key, $value, &$data = array()) { if (is_array($value)) { $v_key = array_keys($value); $c_key = $v_key[0]; if (is_array($value[$c_key])) { $this->merge($c_key, $value[$c_key], $data[$key]); } else { $data[$key][$c_key] = $value[$c_key]; } } else { $data[$key] = $value; } return $data; } }   class WindPropertiesParser { const COMMENT = '#'; const LPROCESS = '['; const RPROCESS = ']'; private $separator = '.'; public function __construct() { } public function parse($filename, $process = true, $build = true) { $data = $this->parse_properties_file($filename, $process); return $build ? $this->buildData($data) : $data; } private function delComment($filename, $process) { } public function parse_properties_file($filename, $process = true) { if (!is_file($filename) || !in_array(substr($filename, strrpos($filename, '.') + 1), array('properties'))) { return array(); } $fp = fopen($filename, 'r'); $content = fread($fp, filesize($filename)); fclose($fp); $content = explode("\n", $content); $data = array(); $last_process = $current_process = ''; foreach ($content as $key => $value) { $value = str_replace(array("\n", "\r"), '', trim($value)); if (0 === strpos(trim($value), self::COMMENT) || in_array(trim($value), array('', "\t", "\n"))) { continue; } $tmp = explode('=', $value, 2); if (0 === strpos(trim($value), self::LPROCESS) && (strlen($value) - 1) === strrpos($value, self::RPROCESS)) { if ($process) { $current_process = $this->trimChar(trim($value), array(self::LPROCESS, self::RPROCESS)); $data[$current_process] = array(); $last_process = $current_process; } continue; } $tmp[0] = trim($tmp[0]); $tmp[1] = trim($tmp[1], '\'"'); if ($last_process) { count($tmp) > 1 ? $data[$last_process][$tmp[0]] = $tmp[1] : $data[$last_process][$tmp[0]] = ''; } else { count($tmp) > 1 ? $data[$tmp[0]] = $tmp[1] : $data[$tmp[0]] = ''; } } return $data; } public function buildData(&$data) { foreach ((array)$data as $key => $value) { if (is_array($value)) { $data[$key] = $this->formatDataArray($value); } else { $this->formatDataFromString($key, $value, $data); } } return $data; } public function toArray($key, $value, &$data = array()) { if (empty($key) && empty($value)) return array(); if (strpos($key, $this->separator)) { $start = substr($key, 0, strpos($key, $this->separator)); $end = substr($key, strpos($key, $this->separator) + 1); $data[$start] = array(); $this->toArray($end, $value, $data[$start]); } else { $data[$key] = $value; } return $data; } public function formatDataArray(&$original, &$data = array()) { foreach ((array)$original as $key => $value) { $tmp = $this->toArray($key, $value); foreach ($tmp as $tkey => $tValue) { if (is_array($tValue)) { if (!isset($data[$tkey])) { $data[$tkey] = array(); } $this->formatDataArray($tValue, $data[$tkey]); } else { $data[$tkey] = $tValue; } } } return $data; } public function formatDataFromString($key, $value, &$data) { $tmp = $this->toArray($key, $value); if(false == strpos($key, $this->separator)){ return $tmp; } $start = substr($key, 0, strpos($key, $this->separator)); if ((!isset($data[$start]) || !is_array($data[$start])) && isset($tmp[$start])) { $data[$start] = $tmp[$start]; } else { foreach ($data as $d_key => $d_value) { if (!isset($tmp[$d_key]) || !is_array($tmp[$d_key])) { continue; } foreach ($tmp[$d_key] as $a => $b) { $this->merge($a, $b, $data[$start]); } } } unset($data[$key]); return $data; } private function merge($key, $value, &$data = array()) { if (is_array($value)) { $v_key = array_keys($value); $c_key = $v_key[0]; if (is_array($value[$c_key])) { $this->merge($c_key, $value[$c_key], $data[$key]); } else { $data[$key][$c_key] = $value[$c_key]; } } else { $data[$key] = $value; } return $data; } private function trimChar($str, $char = ' ') { $char = is_array($char) ? $char : array($char); foreach ($char as $value) { $str = trim($str, $value); } return $str; } }   class WindXmlParser { const NAME = 'name'; private $dom = null; public function __construct($version = '1.0', $encode = 'utf-8') { if (!class_exists('DOMDocument')) throw new WindException('DOMDocument is not exist.'); $this->dom = new DOMDocument($version, $encode); } public function parse($filename, $option = null) { if (!is_file($filename)) return array(); $this->dom->load($filename, $option); return $this->getChilds($this->dom->documentElement); } public function getChilds($node) { if (!$node instanceof DOMElement) return array(); $childs = array(); foreach ($node->childNodes as $node) { $tempChilds = $attributes = array(); ($node->hasAttributes()) && $attributes = $this->getAttributes($node); (3 == $node->nodeType && trim($node->nodeValue)) && $childs[0] = (string) $node->nodeValue; if (1 !== $node->nodeType) continue; $nodeName = ($name = $node->getAttribute(self::NAME)) ? $name : $node->nodeName; $tempChilds = $this->getChilds($node); $tempChilds = array_merge($attributes, $tempChilds); if (empty($tempChilds)) $tempChilds = ''; $tempChilds = (isset($tempChilds[0]) && count($tempChilds) == 1) ? $tempChilds[0] : $tempChilds; if (!isset($childs[$nodeName])) { $childs[$nodeName] = $tempChilds; continue; } else { $element = $childs[$nodeName]; $childs[$nodeName] = (is_array($element) && !is_numeric(implode('', array_keys($element)))) ? array_merge(array( $element), array($tempChilds)) : array_merge((array) $element, array($tempChilds)); continue; } } return $childs; } public function getAttributes($node) { if (!$node instanceof DOMElement || !$node->hasAttributes()) return array(); $attributes = array(); foreach ($node->attributes as $attribute) { if (self::NAME != $attribute->nodeName) { $attributes[$attribute->nodeName] = (string) $attribute->nodeValue; } } return $attributes; } }    abstract class AbstractWindRouter extends WindHandlerInterceptorChain { protected $moduleKey = 'm'; protected $controllerKey = 'c'; protected $actionKey = 'a'; protected $module; protected $controller = 'index'; protected $action = 'run'; protected $currentRoute = null; abstract public function route(); abstract public function assemble(); public function setConfig($config) { parent::setConfig($config); if ($this->_config) { $this->module = $this->getConfig('module', 'default-value', $this->module); $this->controller = $this->getConfig('controller', 'default-value', $this->controller); $this->action = $this->getConfig('action', 'default-value', $this->action); $this->moduleKey = $this->getConfig('module', 'url-param', $this->moduleKey); $this->controllerKey = $this->getConfig('controller', 'url-param', $this->controllerKey); $this->actionKey = $this->getConfig('action', 'url-param', $this->actionKey); } } protected function setParams($params) { foreach ($params as $key => $value) { $this->getRequest()->setAttribute($value, $key); if ($this->actionKey === $key) $this->setAction($value); elseif ($this->controllerKey === $key) $this->setController($value); elseif ($this->moduleKey === $key) $this->setModule($value); } } public function addRoute($routeInstance, $current = false) { if ($current) $this->currentRoute = $routeInstance; $this->addInterceptors($routeInstance); } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function setAction($action) { $this->action = $action; } public function setController($controller) { $this->controller = $controller; } public function getModule() { return $this->module; } public function setModule($module) { $this->module = $module; } public function getModuleKey() { return $this->moduleKey; } public function getControllerKey() { return $this->controllerKey; } public function getActionKey() { return $this->actionKey; } public function setModuleKey($moduleKey) { $this->moduleKey = $moduleKey; } public function setControllerKey($controllerKey) { $this->controllerKey = $controllerKey; } public function setActionKey($actionKey) { $this->actionKey = $actionKey; } }   abstract class AbstractWindRoute extends WindHandlerInterceptor { abstract public function build(); abstract public function match(); public function handle() { $args = func_get_args(); $this->result = call_user_func_array(array($this, 'match'), $args); if ($this->result !== null) { return $this->result; } if (null !== ($handler = $this->interceptorChain->getHandler())) { $this->result = call_user_func_array(array($handler, 'handle'), $args); } else { $this->result = $this->interceptorChain->execute(); } call_user_func_array(array($this, 'postHandle'), $args); return $this->result; } }   Wind::import('COM:router.route.AbstractWindRoute'); class WindRewriteRoute extends AbstractWindRoute { public function build() { } public function match() { } }    class WindRoute extends AbstractWindRoute { protected $params = array(); protected $pattern; protected $reverse; public function match() { } public function build() { } public function setConfig($config) { parent::setConfig($config); $this->setParams($this->getConfig('params')); $this->setPattern($this->getConfig('pattern')); $this->setReverse($this->getConfig('reverse')); } }   Wind::import('COM:router.AbstractWindRouter'); class WindRouter extends AbstractWindRouter { public function route() { $this->setCallBack(array($this, 'defaultRoute')); $params = $this->getHandler()->handle(); $this->setParams($params); } public function assemble() { } public function defaultRoute() { $params[$this->actionKey] = $this->getRequest()->getRequest($this->actionKey, $this->action); $params[$this->controllerKey] = $this->getRequest()->getRequest($this->controllerKey, $this->controller); $params[$this->moduleKey] = $this->getRequest()->getRequest($this->moduleKey, $this->module); return $params; } }    Wind::import('COM:router.AbstractWindRouter'); class WindUrlRewriteRouter extends AbstractWindRouter { private $urlPatttern = ''; private $keyValueSep = ''; private $separator = ''; private $suffix = ''; private $isRewrite = 0; private $keyPrefix = ''; private $baseUrl = ''; private $patterns = array(); public function isRewrite() { return $this->isRewrite == '1' || $this->isRewrite == 'true'; } public function parse() { $this->isRewrite() && $this->parseUrl(); $this->setModule($this->getUrlParamValue('module', $this->getModule())); $this->setController($this->getUrlParamValue('controller', $this->getController())); $this->setAction($this->getUrlParamValue('action', $this->getAction())); } public function parseUrl() { if (!$this->isRewrite()) return; $url = array(); if ($this->getRequest()->getServer('SERVER_PROTOCOL')) { $pathInfo = $this->getRequest()->getServer('PATH_INFO'); if ($pathInfo && !empty($pathInfo)) { $url = rtrim($pathInfo, $this->suffix); } elseif ('' != ($url = $this->getRequest()->getRequestUri())) { $scriptName = $this->getRequest()->getScriptUrl(); if (0 === strpos($url, $scriptName)) { $url = substr($url, strlen($scriptName)); } $url = rtrim($url, $this->suffix); } $url = trim($url, '?/'); $url && $params = $this->doParserUrl($url); } else { $i = 0; $args = $this->getRequest()->getServer('argv', array()); while (isset($args[$i]) && isset($args[$i + 1])) { $params[$args[$i]] = $args[$i + 1]; $i += 2; } } foreach ($params as $k => $v) { !isset($_GET[$k]) && $_GET[$k] = $v; } } public function buildUrl($action = '', $controller = '', $params = array()) { list($module, $controller, $action) = $this->resolveMvc($action, $controller); $m = $this->getConfig('module', 'url-param'); $c = $this->getConfig('controller', 'url-param'); $a = $this->getConfig('action', 'url-param'); $params = array_merge(array($m => $module, $c => $controller, $a => $action), $params); return $this->isRewrite() ? $this->buildRewriteUrl($params) : $this->baseUrl . '/index.php?' . http_build_query( $params, '', '&'); } private function resolveMvc($action, $controller) { list($controller, $module) = WindHelper::resolveController($controller); !$module && $module = $this->getConfig('module', 'default-value'); !$controller && $controller = $this->getConfig('controller', 'default-value'); !$action && $action = $this->getConfig('action', 'default-value'); return array($module, $controller, $action); } private function buildRewriteUrl($params) { $url = $this->urlPatttern; foreach ($this->patterns as $key => $value) { if ('*' == $value[0]) { $url = str_replace($value, $this->buildNomalKeys($params), $url); } else { $url = $this->buildVars($value, $params, $url); } } return $this->baseUrl . '/' . $url . $this->suffix; } private function buildVars($value, &$params, $url) { $keys = explode($this->keyValueSep, $value); $values = array(); foreach ($keys as $v) { if (!isset($params[$v])) continue; $values[] = $params[$v]; unset($params[$v]); } return str_replace($keys, $values, $url); } private function buildNomalKeys($params, $parentKey = '', $first = true) { $tmp = array(); foreach ($params as $k => $v) { if (is_int($k) && $this->keyPrefix != null && $first) { $k = urlencode($this->keyPrefix . $k); } if (!empty($parentKey)) $k = $parentKey . '[' . $k . ']'; if (is_array($v)) { array_push($tmp, $this->buildNomalKeys($v, $k, false)); } else { array_push($tmp, $k . $this->keyValueSep . urlencode($v)); } } return implode($this->separator, $tmp); } private function doParserUrl($url) { if (!$url) return array(); if (is_string($url)) { $url = explode($this->separator, trim($url, $this->separator)); } $vars = array(); foreach ($this->patterns as $key => $value) { if ('*' == $value[0]) $this->parseNomalKeys($key, $url, $vars); else { if (!isset($url[$key])) continue; if (false === strrpos($value, $this->keyValueSep)) { $vars[$value] = $url[$key]; continue; } $keys = explode($this->keyValueSep, $value); $values = explode($this->keyValueSep, $url[$key]); foreach ($keys as $pos => $key) { isset($values[$pos]) && $vars[$key] = $values[$pos]; } } } return $vars; } private function parseNomalKeys($key, $urlParams, &$params) { $pos = 0; while (isset($urlParams[$key])) { if ($this->separator == $this->keyValueSep) { if (isset($urlParams[$key + 1])) { $this->parseKey($params, $urlParams[$key], urldecode($urlParams[$key + 1])); $key += 2; } continue; } if (false === strrpos($urlParams[$key], $this->keyValueSep)) { $params[$this->keyPrefix . $pos] = urldecode($urlParams[$key]); $pos++; } else { list($k, $v) = explode($this->keyValueSep, $urlParams[$key], 2); $this->parseKey($params, $k, urldecode($v)); } $key += 1; } } private function parseKey(&$params, $key, $value) { if (($pos = strpos($key, '[')) === false || ($pos2 = strpos($key, ']', $pos + 1)) === false) { $params[$key] = $value; return; } $name = substr($key, 0, $pos); if ($pos2 === $pos + 1) { $params[$name][] = $value; return; } else { $key = substr($key, $pos + 1, $pos2 - $pos - 1); $params[$name][$key] = $value; return; } } public function setConfig($config) { $usrConfig = $this->getSystemConfig()->getConfig('router', 'config'); $usrConfig && $config = array_merge($config, $usrConfig); parent::setConfig($config); $this->urlPatttern = $this->getConfig('url-pattern'); $this->separator = $this->getConfig('separator'); $this->keyValueSep = $this->getConfig('key-value-sep'); $this->keyValueSep == "" && $this->keyValueSep = $this->separator; $this->suffix = '.' . trim($this->getConfig('suffix'), '.'); $this->isRewrite = $this->getConfig('is-rewrite'); $this->keyPrefix = $this->getConfig('key-prefix'); $this->patterns = explode($this->separator, trim($this->urlPatttern, $this->separator)); $this->baseUrl = rtrim($this->getRequest()->getBaseUrl(true), '/'); if (!$this->isRewrite()) $this->baseUrl = $this->baseUrl . $this->getRequest()->getScriptUrl(); } private function getUrlParamValue($type, $defaultValue = '') { if ($_param = $this->getConfig($type, 'url-param')) { $_defaultValue = $this->getConfig($type, 'default-value', $defaultValue); $tmp = $this->getRequest()->getRequest($_param, $defaultValue); return !$tmp ? $defaultValue : $tmp; } return $defaultValue; } public function route() { } public function assemble() { } } ?>