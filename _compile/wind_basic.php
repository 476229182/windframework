<?php  Wind::import('COM:utility.WindUtility'); class WindModule { protected $_config = array(); protected $_typeValidation = false; private $delayAttributes = array(); public function __set($propertyName, $value) { $_setter = 'set' . ucfirst($propertyName); if (method_exists($this, $_setter)) $this->$_setter($value); } public function __get($propertyName) { $_getter = 'get' . ucfirst($propertyName); if (method_exists($this, $_getter)) return $this->$_getter(); } public function __call($methodName, $args) { $_prefix = substr($methodName, 0, 4); $_propertyName = substr($methodName, 4); $_propertyName = WindUtility::lcfirst($_propertyName); if ($_prefix == '_get') { if (isset($this->delayAttributes[$_propertyName])) { $_property = $this->delayAttributes[$_propertyName]; $_value = null; if (isset($_property['value'])) { $_value = $_property['value']; } elseif (isset($_property['ref'])) { $_value = $this->getSystemFactory()->getInstance($_property['ref'], $args); } elseif (isset($_property['path'])) { $_className = Wind::import($_property['path']); $_value = $this->getSystemFactory()->createInstance($_className, $args); } $this->$_propertyName = $_value; unset($this->delayAttributes[$_propertyName]); } return $this->$_propertyName; } elseif ($_prefix == '_set') { $this->$_propertyName = $args[0]; } throw new WindException( '[core.WindModule.__call] ' . get_class($this) . '->' . $methodName . '()', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } public function __clone() { foreach ($this->writeTableCloneProperty() as $value) { if (!is_object($this->$value) || !isset($this->$value)) continue; $this->$value = clone $this->$value; } } public function toArray() { $reflection = new ReflectionClass(get_class($this)); $properties = $reflection->getProperties(); $_result = array(); foreach ($properties as $property) { $_propertyName = $property->name; $_result[$_propertyName] = $this->$_propertyName; } return $_result; } public function getConfig($configName = '', $subConfigName = '', $default = '', $config = array()) { if (empty($config)) $config = $this->_config; if ($configName === '') return $config; if (!isset($config[$configName])) return $default; if ($subConfigName === '') return $config[$configName]; if (!isset($config[$configName][$subConfigName])) return $default; return $config[$configName][$subConfigName]; } public function setConfig($config) { if (!$config) return; if (is_string($config)) { $configParser = $this->getSystemFactory()->getInstance('configParser'); $config = $configParser->parse($config); } if (!$this->_config) { $this->_config = array_merge($this->_config, (array) $config); } else $this->_config = $config; } protected function writeTableForProperty() { return array('delayAttributes' => 'array'); } protected function writeTableCloneProperty() { return array(); } protected function getSystemFactory() { return Wind::getApp()->getWindFactory(); } protected function getRequest() { return Wind::getApp()->getRequest(); } protected function getResponse() { return Wind::getApp()->getResponse(); } public function setDelayAttributes($delayAttributes) { $this->delayAttributes = array_merge($this->delayAttributes, $delayAttributes); } }   class WindLogger extends WindModule { const LEVEL_INFO = 1; const LEVEL_TRACE = 2; const LEVEL_DEBUG = 3; const LEVEL_ERROR = 4; const LEVEL_PROFILE = 5; const WRITE_ALL = 0; const WRITE_LEVEL = 1; const WRITE_TYPE = 2; const TOKEN_BEGIN = 'begin:'; const TOKEN_END = 'end:'; private $_autoFlush = 1000; private $_logs = array(); private $_logCount = 0; private $_profiles = array(); private $_logDir; private $_maxFileSize = 100; private $_writeType = '0'; private $_types = array(); private $_levelMap = array(self::LEVEL_INFO => 'info', self::LEVEL_ERROR => 'error'); public function __construct($logDir = '', $writeType = 0) { $this->setLogDir($logDir); $this->_writeType = $writeType; } public function info($msg, $type = 'wind.system', $flush = false) { $this->log($msg, self::LEVEL_INFO, $type, $flush); } public function trace($msg, $type = 'wind.system', $flush = false) { $this->log($msg, self::LEVEL_TRACE, $type, $flush); } public function debug($msg, $type = 'wind.system', $flush = false) { $this->log($msg, self::LEVEL_DEBUG, $type, $flush); } public function error($msg, $type = 'wind.core', $flush = false) { $this->log($msg, self::LEVEL_ERROR, $type, $flush); } public function profileBegin($msg, $type = 'wind.core', $flush = false) { $this->log('begin:' . trim($msg), self::LEVEL_PROFILE, $type, $flush); } public function profileEnd($msg, $type = 'wind.core', $flush = false) { $this->log('end:' . trim($msg), self::LEVEL_PROFILE, $type, $flush); } public function log($msg, $level = self::LEVEL_INFO, $type = 'wind.system', $flush = false) { if (!$this->_logDir) return; if ($this->_writeType == self::WRITE_TYPE) (count($this->_types) >= 5 || $this->_logCount >= $this->_autoFlush) && $this->flush(); else $this->_logCount >= $this->_autoFlush && $this->flush(); if ($level === self::LEVEL_PROFILE) $message = $this->_build($msg, $level, $type, microtime(true), $this->getMemoryUsage(false)); elseif ($level === self::LEVEL_DEBUG) $message = $this->_build($msg, $level, $type, microtime(true)); else $message = $this->_build($msg, $level, $type); $this->_logs[] = array($level, $type, $message); $this->_logCount++; if ($this->_writeType == self::WRITE_TYPE && !in_array($type, $this->_types)) $this->_types[] = $type; if ($flush) $this->flush(); } public function flush() { if (empty($this->_logs)) return false; Wind::import('WIND:component.utility.WindFile'); $_l = array(); $_map = array(self::LEVEL_INFO => 'info', self::LEVEL_ERROR => 'error', self::LEVEL_DEBUG => 'debug', self::LEVEL_TRACE => 'trace', self::LEVEL_PROFILE => 'profile'); if ($this->_writeType == self::WRITE_LEVEL) { $_logs = array(); foreach ($this->_logs as $key => $value) { $_l[] = $value[2]; $_logs[$value[0]][] = $value[2]; } foreach ($_logs as $key => $value) { $key = isset($_map[$key]) ? $_map[$key] : 'all'; if (!$fileName = $this->_getFileName($key)) continue; WindFile::write($fileName, join("", $value), 'a'); } } elseif ($this->_writeType == self::WRITE_TYPE) { $_logs = array(); foreach ($this->_logs as $key => $value) { $_l[] = $value[2]; $_logs[$value[1]][] = $value[2]; } foreach ($_logs as $key => $value) { if (!$fileName = $this->_getFileName($key)) continue; WindFile::write($fileName, join("", $value), 'a'); } } if ($fileName = $this->_getFileName()) { WindFile::write($fileName, join("", $_l), 'a'); } $this->_logs = array(); $this->_logCount = 0; return true; } public function getMemoryUsage($peak = true) { if ($peak && function_exists('memory_get_peak_usage')) return memory_get_peak_usage(); elseif (function_exists('memory_get_usage')) return memory_get_usage(); $pid = getmypid(); if (strncmp(PHP_OS, 'WIN', 3) === 0) { exec('tasklist /FI "PID eq ' . $pid . '" /FO LIST', $output); return isset($output[5]) ? preg_replace('/[\D]/', '', $output[5]) * 1024 : 0; } else { exec("ps -eo%mem,rss,pid | grep $pid", $output); $output = explode("  ", $output[0]); return isset($output[1]) ? $output[1] * 1024 : 0; } } private function _build($msg, $level, $type, $timer = 0, $mem = 0) { $msg = stripslashes(str_replace(array("<br/>", "\r\n", "<br>"), "", trim($msg))); $result = ''; switch ($level) { case self::LEVEL_INFO: $msg .= "\t(" . $type . ")"; $result = $this->_buildInfo($msg); break; case self::LEVEL_ERROR: $msg .= "\t(" . $type . ")"; $result = $this->_buildError($msg); break; case self::LEVEL_DEBUG: $msg .= "\t(" . $type . ")\r\n"; $result = $this->_buildDebug($msg); break; case self::LEVEL_TRACE: $msg .= "\t(" . $type . ")"; $result = $this->_buildTrace($msg); break; case self::LEVEL_PROFILE: $result = $this->_buildProfile($msg, $type, $timer, $mem); break; default: break; } return $result ? '[' . date('Y-m-d H:i:s') . '] ' . $result . "\r\n" : ''; } private function _buildProfile($msg, $type, $timer, $mem) { $_msg = ''; if (strncasecmp($msg, self::TOKEN_BEGIN, strlen(self::TOKEN_BEGIN)) == 0) { $_token = substr($msg, strlen(self::TOKEN_BEGIN)); $_token = substr($_token, 0, strpos($_token, ':')); $this->_profiles[] = array($_token, substr($msg, strpos($msg, ':', strlen(self::TOKEN_BEGIN)) + 1), $type, $timer, $mem); } elseif (strncasecmp(self::TOKEN_END, $msg, strlen(self::TOKEN_END)) == 0) { $_msg = "PROFILE! Message: \r\n"; $_token = substr($msg, strlen(self::TOKEN_END)); $_token = substr($_token, 0, strpos($_token, ':')); foreach ($this->_profiles as $key => $profile) { if ($profile[0] !== $_token) continue; if ($profile[1]) $_msg .= $profile[1] . "\r\n"; else $_msg .= substr($msg, strpos($msg, ':', strlen(self::TOKEN_END)) + 1) . "\r\n"; $_msg .= "(type: $profile[2] time: " . ($timer - $profile[3]) . " mem: " . ($mem - $profile[4]) . ")"; break; } unset($this->_profiles[$key]); } return $_msg; } private function _buildInfo($msg) { return "INFO! Message:  " . $msg; } private function _buildTrace($msg) { return "TRACE! Message:  " . $msg . implode("\r\n", $this->_getTrace()); } private function _buildDebug($msg) { return 'DEBUG! Message:  ' . $msg . implode("\r\n", $this->_getTrace()); } private function _buildError($msg) { return 'ERROR! Message:  ' . $msg; } private function _getTrace() { $num = 0; $info[] = 'Stack trace:'; $traces = debug_backtrace(); foreach ($traces as $traceKey => $trace) { if ($num >= 7) break; if ((isset($trace['class']) && $trace['class'] == __CLASS__) || isset($trace['file']) && strrpos( $trace['file'], __CLASS__ . '.php') !== false) continue; $file = isset($trace['file']) ? $trace['file'] . '(' . $trace['line'] . '): ' : '[internal function]: '; $function = isset($trace['class']) ? $trace['class'] . $trace['type'] . $trace['function'] : $trace['function']; if ($function == 'WindBase::log') continue; $args = array_map(array($this, '_buildArg'), $trace['args']); $info[] = '#' . ($num++) . ' ' . $file . $function . '(' . implode(',', $args) . ')'; } return $info; } private function _buildArg($arg) { switch (gettype($arg)) { case 'array': return 'Array'; break; case 'object': return 'Object ' . get_class($arg); break; default: return "'" . $arg . "'"; break; } } private function _getFileName($suffix = '') { $_maxsize = ($this->_maxFileSize ? $this->_maxFileSize : 100) * 1024; $_logfile = $this->_logDir . '/log' . ($suffix ? '_' . $suffix : '') . '.txt'; if (is_file($_logfile) && $_maxsize <= filesize($_logfile)) { $counter = 0; do { $counter++; $_newFile = $_logfile . '_' . date("Y_m_d_{$counter}"); } while (is_file($_newFile)); @rename($_logfile, $_newFile); } return $_logfile; } public function __destruct() { $this->flush(); } public function setLogDir($logDir) { if (!is_dir($logDir)) $logDir = Wind::getRealDir($logDir); $this->_logDir = $logDir; } public function setMaxFileSize($maxFileSize) { $this->_maxFileSize = (int) $maxFileSize; } }    class WindException extends Exception { const ERROR_SYSTEM_ERROR = '0'; const ERROR_CLASS_NOT_EXIST = '100'; const ERROR_CLASS_TYPE_ERROR = '101'; const ERROR_CLASS_METHOD_NOT_EXIST = '102'; const ERROR_OBJECT_NOT_EXIST = '103'; const ERROR_PARAMETER_TYPE_ERROR = '110'; const ERROR_CONFIG_ERROR = '120'; const ERROR_RETURN_TYPE_ERROR = '130'; private $innerException = null; public function __construct($message = '', $code = 0, Exception $innerException = null) { $message = $this->buildMessage($message, $code); parent::__construct($message, $code); $this->innerException = $innerException; } public function getInnerException() { return $this->innerException; } public function getStackTrace() { if ($this->innerException) { $thisTrace = $this->getTrace(); $class = __CLASS__; $innerTrace = $this->innerException instanceof $class ? $this->innerException->getStackTrace() : $this->innerException->getTrace(); foreach ($innerTrace as $trace) $thisTrace[] = $trace; return $thisTrace; } else { return $this->getTrace(); } return array(); } public function buildMessage($message, $code) { $message = str_replace(array("<br />", "<br>", "\r\n"), '', $message); eval('$message="' . addcslashes($this->messageMapper($code), '"') . '";'); return $message; } protected function messageMapper($code) { $messages = array(self::ERROR_SYSTEM_ERROR => 'System error \'$message\'.', self::ERROR_CLASS_TYPE_ERROR => 'Incorrect class type \'$message\'.', self::ERROR_CLASS_NOT_EXIST => 'Unable to create instance for \'$message\' , class is not exist.', self::ERROR_CLASS_METHOD_NOT_EXIST => 'Unable to access the method \'$message\' in current class , the method is not exist or is protected.', self::ERROR_OBJECT_NOT_EXIST => 'Unable to access the object in current class \'$message\' ', self::ERROR_CONFIG_ERROR => 'Incorrect config. the config about \'$message\' error.', self::ERROR_PARAMETER_TYPE_ERROR => 'Incorrect parameter type \'$message\'.', self::ERROR_RETURN_TYPE_ERROR => 'Incorrect return type for \'$message\'.'); return isset($messages[$code]) ? $messages[$code] : '$message'; } }   class WindActionException extends WindException { private $error; public function __construct($error, $code = 0) { $this->setError($error); parent::__construct($error->getError(0), $code); } protected function messageMapper($code) { $messages = array(); return isset($messages[$code]) ? $messages[$code] : '$message'; } public function getError() { return $this->error; } public function setError($error) { $this->error = $error; } }    class WindFinalException extends WindException {}    interface IWindFactory { public function getInstance($classAlias); public function getPrototype($classAlias); static public function createInstance($className, $args = array()); }   class WindClassProxy { const EVENT_TYPE_METHOD = 'method'; const EVENT_TYPE_SETTER = 'setter'; const EVENT_TYPE_GETTER = 'getter'; private $_interceptorChain = 'WIND:core.filter.WindHandlerInterceptorChain'; private $_interceptorChainObj = null; protected $_attributes = array(); protected $_className = ''; protected $_classPath = ''; protected $_reflection = null; protected $_instance = null; protected $_listener = array(); public function __construct($targetObject = null) { $targetObject && $this->registerTargetObject($targetObject); } public function registerEventListener($event, $listener, $type = self::EVENT_TYPE_METHOD) { if (!in_array($type, array(self::EVENT_TYPE_METHOD, self::EVENT_TYPE_GETTER, self::EVENT_TYPE_SETTER))) { throw new WindException( '[core.factory.proxy.WindClassProxy.registerEventListener] Unsupport event type:' . $type, WindException::ERROR_PARAMETER_TYPE_ERROR); } !isset($this->_listener[$type][$event]) && $this->_listener[$type][$event] = array(); array_push($this->_listener[$type][$event], $listener); } public function registerTargetObject($targetObject) { if ($this->_instance !== null || !is_object($targetObject)) return; $this->_setClassName(get_class($targetObject)); $this->_instance = $targetObject; $types = array(self::EVENT_TYPE_METHOD, self::EVENT_TYPE_GETTER, self::EVENT_TYPE_SETTER); foreach ($types as $type) $this->_listener[$type] = array(); return $this; } public function __set($propertyName, $value) { $property = $this->_getReflection()->getProperty($propertyName); if (!$property || !$property->isPublic()) { throw new WindException('undefined property name. '); } $listeners = $this->_getListenerByType(self::EVENT_TYPE_SETTER, $propertyName); if (empty($listeners)) return call_user_func_array(array($this, '_setProperty'), array($propertyName, $value)); $interceptorChain = $this->_getInterceptorChain($propertyName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this, '_setProperty'), array($propertyName, $value)); return $interceptorChain->getHandler()->handle($value); } public function __get($propertyName) { $property = $this->_getReflection()->getProperty($propertyName); if (!$property || !$property->isPublic()) { throw new WindException('undefined property name. '); } $listeners = $this->_getListenerByType(self::EVENT_TYPE_GETTER, $propertyName); if (empty($listeners)) return call_user_func_array(array($this, '_getProperty'), array($propertyName)); $interceptorChain = $this->_getInterceptorChain($propertyName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this, '_getProperty'), array($propertyName)); return $interceptorChain->getHandler()->handle($propertyName); } public function __call($methodName, $args) { $listeners = $this->_getListenerByType(self::EVENT_TYPE_METHOD, $methodName); if (empty($listeners)) return call_user_func_array(array($this->_getInstance(), $methodName), (array) $args); $interceptorChain = $this->_getInterceptorChain($methodName); $interceptorChain->addInterceptors($listeners); $interceptorChain->setCallBack(array($this->_getInstance(), $methodName), $args); return call_user_func_array(array($interceptorChain->getHandler(), 'handle'), (array) $args); } private function _getInterceptorChain($event = '') { if (null === $this->_interceptorChainObj) { $chain = Wind::import($this->_interceptorChain); $interceptorChain = WindFactory::createInstance($chain); if ($interceptorChain && $interceptorChain instanceof WindHandlerInterceptorChain) { $this->_interceptorChainObj = $interceptorChain; } else throw new WindException( '[core.factory.proxy.WindClassProxy._getInterceptorChain] Unable to create interceptorChain.'); } $this->_interceptorChainObj->reset(); return $this->_interceptorChainObj; } private function _getListenerByType($type, $subType) { $listener = array(); if (isset($this->_listener[$type]) && isset($this->_listener[$type][$subType])) { $listener = $this->_listener[$type][$subType]; } return $listener; } public function _getInstance() { return $this->_instance; } public function _getClassName() { return $this->_className; } public function _getClassPath() { return $this->_classPath; } public function _setClassName($className) { $this->_className = $className; } public function _setClassPath($classPath) { $this->_setClassName(Wind::import($classPath)); $this->_classPath = $classPath; } public function _setProperty($propertyName, $value) { $this->_getInstance()->$propertyName = $value; } public function _getProperty($propertyName) { return $this->_getInstance()->$propertyName; } }   Wind::import('COM:utility.WindUtility'); class WindFactory implements IWindFactory { protected $proxyType = 'WIND:core.factory.WindClassProxy'; protected $classDefinitions = array(); protected $instances = array(); protected $prototype = array(); public function __construct($classDefinitions = array()) { if (is_array($classDefinitions)) { $this->classDefinitions = $classDefinitions; } } public function getInstance($alias, $args = array()) { if (isset($this->prototype[$alias])) return clone $this->prototype[$alias]; if (isset($this->instances[$alias])) return $this->instances[$alias]; if (!isset($this->classDefinitions[$alias]) || !($definition = $this->classDefinitions[$alias])) return null; if (isset($definition['constructor-arg'])) foreach ((array) $definition['constructor-arg'] as $_var) { if (isset($_var['value'])) { $args[] = $_var['value']; } elseif (isset($_var['ref'])) $args[] = $this->getInstance($_var['ref']); } if (!isset($definition['className'])) $definition['className'] = Wind::import(@$definition['path']); $instance = $this->createInstance($definition['className'], $args); if (isset($definition['config'])) $this->resolveConfig($definition['config'], $alias, $instance); if (isset($definition['properties'])) $this->buildProperties($definition['properties'], $instance); if (isset($definition['initMethod'])) $this->executeInitMethod($definition['initMethod'], $instance); if (isset($definition['proxy'])) $instance = $this->setProxyForClass($definition['proxy'], $instance); $this->setScope($alias, $definition['scope'], $instance); return $instance; } public function registInstance($instance, $alias, $scope = 'singleton') { if (!is_object($instance) || !$alias) return false; return $this->setScope($alias, $scope, $instance); } static public function createInstance($className, $args = array()) { try { if (empty($args)) { return new $className(); } else { $reflection = new ReflectionClass($className); return call_user_func_array(array($reflection, 'newInstance'), (array) $args); } } catch (Exception $e) { throw new WindException($className, WindException::ERROR_CLASS_NOT_EXIST); } } public function getPrototype($alias) { return isset($this->prototype[$alias]) ? clone $this->prototype[$alias] : null; } public function addClassDefinitions($alias, $classDefinition) { if (!is_string($alias) || empty($alias)) { throw new WindException( '[core.factory.WindFactory.addClassDefinitions] class alias is empty.', WindException::ERROR_PARAMETER_TYPE_ERROR); } if (isset($this->classDefinitions[$alias])) return; $this->classDefinitions[$alias] = $classDefinition; } public function loadClassDefinitions($classDefinitions, $merge = true) { foreach ((array) $classDefinitions as $alias => $definition) { if (!is_array($definition)) continue; if (!isset($this->classDefinitions[$alias]) || $merge === false) { $this->classDefinitions[$alias] = $definition; continue; } $this->classDefinitions[$alias] = WindUtility::mergeArray( $this->classDefinitions[$alias], $definition); unset($this->instances[$alias], $this->prototype[$alias]); } } public function checkAlias($alias) { if (isset($this->prototype[$alias])) return true; elseif (isset($this->instances[$alias])) return true; return false; } protected function setScope($alias, $scope, $instance) { switch ($scope) { case 'prototype': $this->prototype[$alias] = clone $instance; break; case 'application': $this->instances[$alias] = $instance; break; default: $this->instances[$alias] = $instance; break; } return true; } protected function resolveConfig($config, $alias, $instance) { if (isset($config['resource'])) { $_configPath = Wind::getRealPath($config['resource'], true); $configParser = $this->getInstance('configParser'); $config = $configParser->parse($_configPath, $alias, true, $this->getInstance('windCache')); } if ($config && method_exists($instance, 'setConfig')) $instance->setConfig($config); } protected function executeInitMethod($initMethod, $instance) { try { return call_user_func_array(array($instance, $initMethod), array()); } catch (Exception $e) { throw new WindException( '[core.factory.WindFactory.executeInitMethod] (' . $initMethod . ', ' . $e->getMessage() . ')', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } } protected function setProxyForClass($proxy, $instance) { if ($proxy === 'false' || $proxy === false) return $instance; if ($proxy === 'true' || $proxy === true) $proxy = $this->proxyType; $this->addClassDefinitions($proxy, array('path' => $proxy, 'scope' => 'prototype')); return $this->getInstance($proxy)->registerTargetObject($instance); } protected function buildProperties($properties, $instance) { if (!isset($properties['delay'])) { $instance->setDelayAttributes($properties); } elseif ($properties['delay'] === 'false' || $properties['delay'] === false) { foreach ($properties as $key => $subDefinition) { $_value = ''; if (isset($subDefinition['value'])) $_value = $subDefinition['value']; elseif (isset($subDefinition['ref'])) $_value = $this->getInstance($subDefinition['ref']); elseif (isset($subDefinition['path'])) { $_className = Wind::import($subDefinition['path']); $_value = $this->createInstance($_className); } $_setter = 'set' . ucfirst(trim($key, '_')); if (method_exists($instance, $_setter)) call_user_func_array(array($instance, $_setter), array($_value)); } } else $instance->setDelayAttributes($properties); } }   class WindHandlerInterceptor extends WindModule { protected $result = null; protected $interceptorChain = null; public function preHandle() {} public function postHandle() {} public function handle() { $args = func_get_args(); $this->result = call_user_func_array(array($this, 'preHandle'), $args); if ($this->result !== null) { return $this->result; } if (null !== ($handler = $this->interceptorChain->getHandler())) { $this->result = call_user_func_array(array($handler, 'handle'), $args); } else { $this->result = $this->interceptorChain->execute(); } call_user_func_array(array($this, 'postHandle'), $args); return $this->result; } public function setHandlerInterceptorChain($interceptorChain) { $this->interceptorChain = $interceptorChain; } }   Wind::import('COM:fitler.WindHandlerInterceptor'); class WindFilter extends WindHandlerInterceptor { public function preHandle() { } public function postHandle() { } }   class WindHandlerInterceptorChain extends WindModule { protected $_interceptors = array(); protected $_callBack = null; protected $_args = array(); protected $_state = 0; public function setCallBack($callBack, $args = array()) { $this->_callBack = $callBack; $this->_args = $args; } public function execute() { if ($this->_callBack === null) return null; if (is_string($this->_callBack) && !function_exists($this->_callBack)) { throw new WindException( '[core.filter.WindHandlerInterceptorChain.execute]' . $this->_callBack, WindException::ERROR_FUNCTION_NOT_EXIST); } return call_user_func_array($this->_callBack, (array) $this->_args); } public function getHandler() { if (count($this->_interceptors) <= 0) { $this->addInterceptors(new WindHandlerInterceptor()); } if ($this->_state >= count($this->_interceptors)) return null; $handler = $this->_interceptors[$this->_state++]; if ($handler instanceof WindHandlerInterceptor) { $handler->setHandlerInterceptorChain($this); return $handler; } return $this->getHandler(); } public function addInterceptors($interceptors) { if (is_array($interceptors)) $this->_interceptors += $interceptors; else $this->_interceptors[] = $interceptors; } public function reset() { $this->_interceptors = array(); $this->_callBack = null; $this->_args = array(); $this->_state = 0; return true; } }    class WindFilterChain extends WindHandlerInterceptorChain { public function __construct($filterConfig) { $this->_initFilters($filterConfig); } public function deleteFilter($alias) { unset($this->_interceptors[$alias]); } public function addFilter($filter, $beforFilter = '') { if ($beforFilter === '') { $this->addInterceptors(array(get_class($filter) => $filter)); return true; } $_interceptors = array(); foreach ($this->_interceptors as $key => $interceptor) { if ($beforFilter === $key) break; $_interceptors[$key] = $interceptor; unset($this->_interceptors[$key]); } $_interceptors[get_class($filter)] = $filter; $this->_interceptors = (array) $_interceptors + (array) $this->_interceptors; } private function _initFilters($filters = array()) { $_temp = array(); foreach ((array) $filters as $key => $filter) { if (!is_array($filter)) continue; $filterClass = Wind::import($filter[WindSystemConfig::CLASS_PATH]); if (!class_exists($filterClass)) continue; $_temp[$key] = new $filterClass(); } $this->addInterceptors($_temp); } }   interface IWindApplication { public function run(); public function getRequest(); public function getResponse(); public function getWindFactory(); }    class WindUrlFilter extends WindFilter { public function preHandle($request = null, $response = null) { } public function postHandle($request = null, $response = null) { } }    class WindFormListener extends WindHandlerInterceptor { private $request = null; private $formPath = ''; private $errorMessage = null; public function __construct($request, $formPath, $errorMessage) { $this->request = $request; $this->formPath = $formPath; $this->errorMessage = $errorMessage; } public function preHandle() { $className = Wind::import($this->formPath); if (!class_exists($className)) throw new WindException('the form \'' . $this->formPath . '\' is not exists!'); if ('WindEnableValidateModule' != get_parent_class($className)) throw new WindException( 'the form \'' . $this->formPath . '\' is not extends \'WindEnableValidateModule\'!'); $form = new $className(); $methods = get_class_methods($form); foreach ($methods as $method) { if ((0 !== strpos($method, 'set')) || ('' == ($_tmp = substr($method, 3)))) continue; $_tmp[0] = strtolower($_tmp[0]); $value = $this->request->getPost($_tmp) ? $this->request->getPost($_tmp) : $this->request->getGet( $_tmp); if (null === $value) continue; call_user_func_array(array($form, $method), array($value)); } call_user_func_array(array($form, 'validate'), array($form)); if (($error = $form->getErrors())) { list($errorController, $errorAction) = $form->getErrorControllerAndAction(); $this->sendError($errorController, $errorAction, $error); } $this->request->setAttribute('formData', $form); } private function sendError($errorController, $errorAction, $errors) { if (!$this->errorMessage instanceof WindErrorMessage) $this->errorMessage = new WindErrorMessage(); $this->errorMessage->setErrorController($errorController); $this->errorMessage->setErrorAction($errorAction); $this->errorMessage->addError($errors); $this->errorMessage->sendError(); } public function postHandle() { } }   Wind::import('COM:fitler.WindHandlerInterceptor'); class WindLoggerListener extends WindHandlerInterceptor { public function __construct($request) { $this->request = $request; } public function preHandle() { $logger = $this->getLogger(); if ($logger instanceof WindLogger) { $logger->info($this->getPreLogMessage(func_get_args())); } } public function postHandle() { $logger = $this->getLogger(); if ($logger instanceof WindLogger) { $logger->info($this->getPostLogMessage(func_get_args())); } } private function getLogger() { if (!isset($this->logger)) { $factory = $this->request->getAttribute(WindFrontController::WIND_FACTORY); $this->logger = $factory->getInstance(COMPONENT_LOGGER); } return $this->logger; } private function getPreLogMessage($args) { $log = $this->getLogMessage($args); $log['caller'] = ' #[caller]: ' . $log['caller']; $log['excute'] = ' #[excute-begin]: ' . $log['excute']; $message = 'Begin ' . $this->event[0] . '->' . $this->event[1]; return "{$message}<br/>" . implode("\r\n", $log) . '<br/>'; } private function getPostLogMessage($args) { $log = $this->getLogMessage($args); $log['caller'] = ' #[caller]: ' . $log['caller']; $log['excute'] = ' #[excute-end]: ' . $log['excute']; $log['output'] = ' #[output]: ' . $this->buildArg($this->result); $message = 'End ' . $this->event[0] . '->' . $this->event[1]; return "{$message}<br/>" . implode("\r\n", $log) . '<br/>'; } private function getLogMessage($args) { $method = ''; $info = array(); $flag = false; foreach (debug_backtrace(false) as $traceKey => $trace) { $class = isset($trace['class']) ? $trace['class'] : ''; if (in_array($class, array('', 'WindLogger', __CLASS__, 'WindHandlerInterceptor'))) continue; $function = isset($trace['function']) ? $trace['function'] : ''; ($class == 'WindClassProxy' && $function == '__call') && $method = trim( $trace['args'][0]); ($function == $method) && $flag = true; if (!isset($trace['file'])) continue; $info['caller'] = addslashes($trace['file']) . '(' . $trace['line'] . '): '; break; } list($class, $method) = $this->event; $args = array_map(array($this, 'buildArg'), $args); $info['excute'] = $class . '->' . $method . '(' . implode(', ', $args) . ')'; return $info; } private function buildArg($arg) { switch (gettype($arg)) { case 'array': return 'Array'; break; case 'object': return 'Object ' . get_class($arg); break; default: return "'" . $arg . "'"; break; } } }   Wind::import('COM:fitler.WindHandlerInterceptor'); class WindValidateListener extends WindHandlerInterceptor { private $request = null; private $validateRules = array(); private $validator = null; private $validatorClass = ''; private $defaultMessage = '验证失败'; public function __construct($request, $validateRules, $validatorClass) { $this->request = $request; $this->validateRules = (array) $validateRules; $this->validatorClass = $validatorClass; } public function preHandle() { if (!isset($this->validateRules['errorMessage'])) $errorMessage = new WindErrorMessage(); else { $errorMessage = $this->validateRules['errorMessage']; unset($this->validateRules['errorMessage']); } $_input = new stdClass(); foreach ((array) $this->validateRules as $rule) { if (!is_array($rule)) continue; $key = $rule['field']; $value = $this->request->getGet($key) ? $this->request->getGet($key) : $this->request->getPost( $key); $args = $rule['args']; array_unshift($args, $value); if (call_user_func_array(array($this->getValidator(), $rule['validator']), (array) $args) === false) { if (null === $rule['default']) $errorMessage->addError( ($rule['message'] ? $rule['message'] : $this->defaultMessage), $key); else $value = $rule['default']; } $this->request->setAttribute($key, $value); $_input->$key = $value; } if ($errorMessage->getError()) $errorMessage->sendError(); else $this->request->setAttribute('inputData', $_input); } private function getValidator() { if ($this->validator === null) { $_className = Wind::import($this->validatorClass); $this->validator = WindFactory::createInstance($_className); if ($this->validator === null) throw new WindException('validator', WindException::ERROR_RETURN_TYPE_ERROR); } return $this->validator; } public function postHandle() { } }    abstract class WindSimpleController extends WindModule implements IWindController { protected $forward = null; protected $errorMessage = null; abstract public function run(); protected function beforeAction($handlerAdapter) {} protected function afterAction($handlerAdapter) {} public function preAction($handlerAdapter) { $this->urlHelper = null; $this->errorMessage = null; $this->forward = null; } public function postAction($handlerAdapter) {} public function doAction($handlerAdapter) { $this->beforeAction($handlerAdapter); $this->setDefaultTemplateName($handlerAdapter); $method = $this->resolvedActionMethod($handlerAdapter); call_user_func_array(array($this, $method), array()); if ($this->errorMessage !== null) $this->getErrorMessage()->sendError(); $this->afterAction($handlerAdapter); return $this->forward; } protected function forwardAction($action = 'run', $controller = '', $args = array(), $isRedirect = false) { $this->getForward()->forwardAnotherAction($action, $controller, $args, $isRedirect); } protected function forwardRedirect($url) { $this->getForward()->setIsRedirect(true); $this->getForward()->setUrl($url); } protected function setOutput($data, $key = '') { $this->getForward()->setVars($data, $key); } protected function setGlobal($data, $key = '') { $this->getResponse()->setData($data, $key, true); } protected function getInput($name, $type = '', $callback = null) { if (is_array($name)) return $this->getInputWithArray($name, $type); else return $this->getInputWithString($name, $type, $callback); } protected function setTemplate($template) { $this->getForward()->setTemplateName($template); } protected function setTemplatePath($templatePath) { $this->getForward()->setTemplatePath($templatePath); } protected function setTemplateExt($templateExt) { $this->getForward()->setTemplateExt($templateExt); } protected function setLayout($layout) { $this->getForward()->setLayout($layout); } protected function addMessage($message, $key = '') { $this->getErrorMessage()->addError($message, $key); } protected function showMessage($message = '', $key = '', $errorAction = '') { $this->addMessage($message, $key); $this->getErrorMessage()->setErrorAction($errorAction); $this->getErrorMessage()->sendError(); } protected function setDefaultTemplateName($handlerAdapter) {} protected function resolvedActionMethod($handlerAdapter) { return 'run'; } private function getInputWithString($name, $type = '', $callback = array()) { $value = ''; switch (strtolower($type)) { case 'form': $value = $this->response->getData($name); break; case IWindRequest::INPUT_TYPE_GET: $value = $this->request->getGet($name); break; case IWindRequest::INPUT_TYPE_POST: $value = $this->request->getPost($name); break; case IWindRequest::INPUT_TYPE_COOKIE: $value = $this->request->getCookie($name); break; default: $value = $this->request->getAttribute($name); } return $callback ? array($value, call_user_func_array($callback, array($value))) : $value; } private function getInputWithArray($name, $type = '') { $result = array(); foreach ($name as $key => $value) { $result[(is_array($value) ? $key : $value)] = $this->getInput($value, $type); } return $result; } protected function getForward() { return $this->_getForward(); } protected function getErrorMessage() { return $this->_getErrorMessage(); } } interface IWindController { public function doAction($handlerAdapter); public function preAction($handlerAdapter); public function postAction($handlerAdapter); }    abstract class WindController extends WindSimpleController { protected $validatorClass = 'WIND:component.utility.WindValidator'; protected $formClass = ''; final public function preAction($handlerAdapter) { parent::preAction($handlerAdapter); if ($formClassPath = $this->getFormClass()) { $this->registerEventListener('doAction', new WindFormListener($this->request, $formClassPath, $this->getErrorMessage())); } elseif ($rules = $this->validatorFormRule($handlerAdapter->getAction())) { if (!isset($rules['errorMessage'])) { $rules['errorMessage'] = $this->getErrorMessage(); } $this->registerEventListener('doAction', new WindValidateListener($this->request, $rules, $this->getValidatorClass())); } return true; } protected function setDefaultTemplateName($handlerAdapter) { } protected function resolvedActionMethod($handlerAdapter) { $action = $handlerAdapter->getAction(); if ($action !== 'run') $action = $this->resolvedActionName($action); if ($action == 'doAction') { throw new WindException('[core.web.WindController.resolvedActionMethod]', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } $method = new ReflectionMethod($this, $action); if ($method->isAbstract() || !$method->isPublic()) { throw new WindException('[core.web.WindController.resolvedActionMethod]', WindException::ERROR_CLASS_METHOD_NOT_EXIST); } return $action; } protected function resolvedActionName($action) { return $action . 'Action'; } protected function validatorFormRule($type) { return array(); } protected function getFormClass() { return $this->formClass; } protected function getValidatorClass() { return $this->validatorClass; } }  Wind::import('COM:viewer.exception.WindViewException'); class WindDispatcher extends WindModule { protected $processCache = array(); protected $display = false; public function dispatch($forward, $router, $display) { $this->checkProcess($router, false); if ($forward->getIsRedirect()) $this->dispatchWithRedirect($forward, $router); elseif ($forward->getIsReAction()) $this->dispatchWithAction($forward, $router, $display); else $this->render($forward, $router); } protected function dispatchWithRedirect($forward, $router) { $_url = $forward->getUrl(); if (!$_url && $forward->getIsReAction()) { $_url = $this->_getUrlHelper()->createUrl($forward->getAction(), $forward->getController(), $forward->getArgs()); $router->reParse(); if (!$this->checkProcess($router)) { throw new WindFinalException( '[core.web.WindDispatcher.dispatchWithRedirect] Duplicate request: ' . $router->getController() . ',' . $router->getAction(), WindException::ERROR_SYSTEM_ERROR); } } else $_url = $this->_getUrlHelper()->checkUrl($_url); $this->getResponse()->sendRedirect($_url); } protected function dispatchWithAction($forward, $router, $display) { if (!$action = $forward->getAction()) throw new WindException('[core.web.WindDispatcher.dispatchWithAction] forward fail.', WindException::ERROR_PARAMETER_TYPE_ERROR); $args = $forward->getArgs(); $this->display = $display; list($action, $_args) = explode('?', $action . '?'); $action = trim($action, '/') . '/'; $action = explode('/', $action); end($action); if ($_tmp = prev($action)) $router->setAction($_tmp); if ($_tmp = prev($action)) $router->setController($_tmp); if ($_tmp = prev($action)) $router->setModule($_tmp); if (!$this->checkProcess($router)) { throw new WindFinalException( '[core.web.WindDispatcher.dispatchWithRedirect] Duplicate request: ' . $router->getController() . ',' . $router->getAction(), WindException::ERROR_SYSTEM_ERROR); } Wind::getApp()->processRequest(); } protected function render($forward, $router) { if ($windViewClass = $forward->getWindView()) { $_className = Wind::import($windViewClass); $view = $this->getSystemFactory()->createInstance($windViewClass); } else $view = $this->getSystemFactory()->getInstance('windView'); $view->render($forward, $router, $this->display); $this->display = false; } protected function checkProcess($router, $check = true) { if ($check === false) { $this->processCache['action'] = $router->getAction(); $this->processCache['controller'] = $router->getController(); $this->processCache['module'] = $router->getModule(); } elseif ($router->getAction() === @$this->processCache['action'] && $router->getController() === @$this->processCache['controller'] && $router->getModule() === @$this->processCache['module']) return false; return true; } }    class WindErrorHandler extends WindController { protected $error = array(); protected $errorCode = 0; protected $urlReferer = ''; public function beforeAction($handlerAdapter) { $this->error = $this->getInput('error'); $this->errorCode = (int) $this->getInput('errorCode'); if ($this->request->getUrlReferer()) $this->urlReferer = $this->getRequest()->getUrlReferer(); else $this->urlReferer = $this->getRequest()->getBaseUrl(); } public function run() { if ($this->errorCode >= 400 && $this->errorCode <= 505) { $_statusMsg = ucwords($this->getResponse()->codeMap($this->errorCode)); $topic = "$this->errorCode - " . $_statusMsg; $this->getResponse()->setStatus($this->errorCode); } else $topic = "Error message"; $this->setOutput($topic, "errorHeader"); $this->setOutput($this->urlReferer, "baseUrl"); $this->setOutput($this->error, "errors"); $this->setTemplatePath('COM:viewer.errorPage'); $this->setTemplate('default_error'); } }   class WindForward extends WindModule { private $windView; private $templateName; private $templatePath = null; private $templateExt = null; private $layout; private $vars = array(); private $isReAction = false; private $isRedirect = false; private $url; private $action; private $controller; private $args; public function forwardAnotherAction($action = 'run', $controller = '', $args = array(), $isRedirect = false) { $this->setIsReAction(true); $this->setAction($action); $this->setController($controller); $this->setArgs($args); $this->setIsRedirect($isRedirect); } public function forwardAction($action, $args = array(), $isRedirect = false) { $this->setIsReAction(true); $this->setAction($action); $this->setArgs($args); $this->setIsRedirect($isRedirect); } public function setVars($vars, $key = '') { if (!$key) { if (is_object($vars)) $vars = get_object_vars($vars); if (is_array($vars)) $this->vars += $vars; } else $this->vars[$key] = $vars; return; } public function getIsRedirect() { return $this->isRedirect; } public function setIsRedirect($isRedirect) { $this->isRedirect = $isRedirect; } public function getIsReAction() { return $this->isReAction; } public function setIsReAction($isReAction) { $this->isReAction = $isReAction; } public function getVars() { return $this->vars; } public function getUrl() { return $this->url; } public function setUrl($url) { $this->url = $url; } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function getArgs() { return $this->args; } public function setAction($action) { $this->action = $action; } public function setController($controller) { $this->controller = $controller; } public function setArgs($args) { $this->args = $args; } public function getTemplateName() { return $this->templateName; } public function getTemplatePath() { return $this->templatePath; } public function getTemplateExt() { return $this->templateExt; } public function getLayout() { return $this->layout; } public function setTemplateName($templateName) { $this->templateName = $templateName; } public function setTemplatePath($templatePath) { $this->templatePath = $templatePath; } public function setTemplateExt($templateExt) { $this->templateExt = $templateExt; } public function setLayout($layout) { $this->layout = $layout; } public function getWindView() { return $this->windView; } public function setWindView($windView) { $this->windView = $windView; } }   class WindSystemConfig extends WindModule { private $appName = ''; private $modules = array(); public function __construct($config, $appName, $factory) { $this->appName = $appName; $this->setConfig($config, $factory); } public function setConfig($config, $factory = null) { if (empty($config)) return; if (is_string($config)) { $configParser = $factory->getInstance('configParser'); $config = $configParser->parse($config); if (isset($config[$this->appName])) $this->_config = $config[$this->appName]; } else $this->_config = $this->_config ? array_merge($this->_config, $config) : (array) $config; } public function getAppName() { return $this->appName; } public function getAppClass($default = '') { return $this->getConfig('class', '', $default); } public function getCharset() { return $this->getConfig('charset', '', 'utf-8'); } public function getFilters() { return $this->getConfig('filters'); } public function getFilterClass() { return $this->getConfig('filters', 'class'); } public function getRouter() { return $this->getConfig('router'); } public function getRouterClass() { return $this->getConfig('router', 'class', COMPONENT_ROUTER); } public function getModules($name = '') { return $this->getConfig('modules', $name, array()); } public function setModules($name, $config = array()) { if (!$_default = @$this->_config['modules']['default']) { $_default = $this->getDefaultConfigStruct('modules'); $this->_config['modules']['default'] = $_default; } if (!$config) $this->_config['modules'][$name] = $_default; else $this->_config['modules'][$name] = WindUtility::mergeArray($_default, $config); return $this->_config['modules'][$name]; } public function getModuleTemplateDir($name, $default = '') { return $this->getConfig('template-dir', '', $default, $this->getModules($name)); } public function getModuleErrorHandler($name, $default = '') { return $this->getConfig('errorhandler', '', $default, $this->getModules($name)); } public function getModuleControllerPath($name, $default = '') { return $this->getConfig('controller-path', '', $default, $this->getModules($name)); } public function getModuleControllerSuffix($name, $default = '') { return $this->getConfig('controller-suffix', '', $default, $this->getModules($name)); } public function getComponents($name = '', $default = array()) { return $this->getConfig('components', $name, $default); } public function getDbConfig($dbName = '') { $config = $this->getConfig('db'); if (isset($config['resource']) && !empty($config['resource'])) { $_resource = Wind::getRealPath($config['resource'], true); $this->_config['db'] = $this->parseConfig($_resource, 'db'); } return $this->getConfig('db', $dbName); } private function parseConfig($config, $key = 'config', $append = true) { if (!$config) return array(); $configParser = $this->getSystemConfig()->getInstance('configParser'); return $configParser->parse($config); } public function getDefaultConfigStruct($configName) { $_tmp = array(); $_tmp['modules']['controller-path'] = $this->getConfig('controller-path', '', 'controller'); $_tmp['modules']['controller-suffix'] = $this->getConfig('controller-suffix', '', 'Controller'); $_tmp['modules']['error-handler'] = $this->getConfig('error-handler', '', 'WIND:core.web.WindErrorHandler'); return $configName ? (isset($_tmp[$configName]) ? $_tmp[$configName] : array()) : array(); } }   class WindUrlHelper extends WindModule { public function createUrl($action, $controller = '', $params = array()) { $router = $this->getSystemFactory()->getInstance(COMPONENT_ROUTER); return $router->buildUrl($action, $controller, $params); } }   Wind::import('COM:http.request.WindHttpRequest'); Wind::import('COM:http.response.WindHttpResponse'); class WindWebApplication extends WindModule implements IWindApplication { private $request; private $response; protected $windFactory = null; protected $dispatcher = null; protected $handlerAdapter = null; protected $filterChain = 'WIND:filter.WindFilterChain'; public function __construct($config, $factory) { $this->request = new WindHttpRequest(); $this->response = $this->request->getResponse(@$config['charset']); $this->windFactory = $factory; $this->setConfig($config); } public function run() { set_error_handler('WindHelper::errorHandle'); set_exception_handler('WindHelper::exceptionHandle'); $this->windFactory->loadClassDefinitions($this->getConfig('components')); $this->_getHandlerAdapter()->route(); if (null == ($filterChain = $this->getFilterChain())) { $this->processRequest(); } else { $filterChain->setCallBack(array($this, 'processRequest')); $filterChain->getHandler()->handle($this->request, $this->response); } restore_error_handler(); restore_exception_handler(); $this->response->sendResponse(); Wind::resetApp(); } public function doDispatch($forward, $display = false) { if ($forward === null) return; $moduleName = $this->handlerAdapter->getModule(); if (!($module = $this->getModules($moduleName))) throw new WindActionException( '[core.web.WindWebApplication.doDispatch] Your requested \'' . $moduleName . '\' was not found on this server.', 404); if ($forward->getTemplateExt() === null && isset($module['template-ext'])) $forward->setTemplateExt($module['template-ext']); if ($forward->getTemplatePath() === null && isset($module['template-dir'])) $forward->setTemplatePath($module['template-dir']); $this->_getDispatcher()->dispatch($forward, $this->handlerAdapter, $display); } public function processRequest() { try { $moduleName = $this->handlerAdapter->getModule(); if (!$moduleName) { $moduleName = 'default'; $this->handlerAdapter->setModule($moduleName); $module = $this->setModules($moduleName); } else { if (!($module = $this->getModules($moduleName))) throw new WindActionException( '[core.web.WindWebApplication.processRequest] Your requested \'' . $moduleName . '\' was not found on this server.', 404); $module = $this->setModules($moduleName, $module); } $handlerPath = @$module['controller-path'] . '.' . ucfirst( $this->handlerAdapter->getController()) . @$module['controller-suffix']; $handlerPath = trim($handlerPath, '.'); if (!$handlerPath) throw new WindActionException( '[core.web.WindWebApplication.processRequest] Your requested \'' . $handlerPath . '\' was not found on this server.', 404); strpos($handlerPath, ':') === false && $handlerPath = Wind::getAppName() . ':' . $handlerPath; $this->getSystemFactory()->addClassDefinitions($handlerPath, array('path' => $handlerPath, 'scope' => 'singleton', 'proxy' => true, 'properties' => array('errorMessage' => array('ref' => 'errorMessage'), 'forward' => array('ref' => 'forward'), 'urlHelper' => array('ref' => 'urlHelper')))); $handler = $this->windFactory->getInstance($handlerPath); if (!$handler) throw new WindActionException( '[core.web.WindWebApplication.processRequest] Your requested \'' . $handlerPath . '\' was not found on this server.', 404); $handler->preAction($this->handlerAdapter); $forward = $handler->doAction($this->handlerAdapter); $handler->postAction($this->handlerAdapter); $this->doDispatch($forward); } catch (WindActionException $e) { $this->sendErrorMessage($e); } catch (WindViewException $e) { $this->sendErrorMessage($e); } } protected function sendErrorMessage($exception) { $moduleName = $this->handlerAdapter->getModule(); if ($moduleName === 'error' || !($module = $this->getModules($moduleName))) throw new WindException($exception->getMessage()); $errorMessage = null; if ($exception instanceof WindActionException) $errorMessage = $exception->getError(); if (!$errorMessage) { $errorMessage = $this->windFactory->getInstance('errorMessage'); $errorMessage->addError($exception->getMessage()); } if (!$_errorAction = $errorMessage->getErrorAction()) { preg_match("/([a-zA-Z]*)$/", @$module['error-handler'], $matchs); $_errorHandler = trim(substr(@$module['error-handler'], 0, -(strlen(@$matchs[0])))); $_errorAction = 'error/' . @$matchs[0] . '/run/'; $this->setModules('error', array('controller-path' => $_errorHandler, 'controller-suffix' => '', 'error-handler' => '')); } $forward = $this->getSystemFactory()->getInstance('forward'); $forward->forwardAction($_errorAction); $this->getRequest()->setAttribute($errorMessage->getError(), 'error'); $this->getRequest()->setAttribute($exception->getCode(), 'errorCode'); $this->doDispatch($forward); } protected function getFilterChain() { if (!$filters = $this->getConfig('filters')) return null; $filterChainPath = @$filters['class'] ? $filters['class'] : $this->filterChain; unset($filters['class']); if (empty($filters)) return null; $this->windFactory->addClassDefinitions($filterChainPath, array('path' => $filterChainPath, 'scope' => 'singleton')); return $this->windFactory->getInstance($filterChainPath, array($filters)); } public function setModules($name, $config = array()) { if (isset($this->_config['modules']['default'])) $_default = $this->_config['modules']['default']; else { $_default = array('controller-path' => 'controller', 'controller-suffix' => 'Controller', 'error-handler' => 'WIND:core.web.WindErrorHandler'); $this->_config['modules']['default'] = $_default; } if (!$config) $this->_config['modules'][$name] = $_default; else $this->_config['modules'][$name] = WindUtility::mergeArray($_default, $config); return $this->_config['modules'][$name]; } public function getModules($name = '') { return $this->getConfig('modules', $name, array()); } public function setConfig($config) { if (!$config) return; $config = @$config[Wind::getAppName()] ? $config[Wind::getAppName()] : $config; $this->_config = $config; } public function registeComponent($componentName, $componentInstance, $scope) { return $this->windFactory->registInstance($componentInstance, $componentName); } public function getComponent($componentName) { return $this->windFactory->getInstance($componentName); } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function getWindFactory() { return $this->windFactory; } }   class WindEnableValidateModule extends WindModule { protected $_validatorClass = 'WIND:component.utility.WindValidator'; protected $errorController = ''; protected $errorAction = ''; private $_validator = null; private $_errors = array(); private $_defaultMessage = 'the field validate fail.'; public function getErrors() { return $this->_errors; } public function getErrorControllerAndAction() { return array($this->errorController, $this->errorAction); } protected function validateRules() { return array(); } public function validate(&$input) { if (is_array($input)) $this->validateArray($input); elseif (is_object($input)) $this->validateObject($input); } private function validateArray(&$input) { $rules = $this->validateRules(); foreach ((array) $rules as $rule) { $_input = isset($input[$rule['field']]) ? $input[$rule['field']] : ''; $arg = (array) $rule['args']; array_unshift($arg, $_input); if (call_user_func_array(array($this->getValidator(), $rule['validator']), $arg) !== false) continue; if ($rule['default'] === null) { $this->_errors[$rule['field']] = $rule['message']; continue; } $input[$rule['field']] = $rule['default']; } } private function validateObject(&$input) { $rules = $this->validateRules(); $methods = get_class_methods($input); foreach ((array) $rules as $rule) { $getMethod = 'get' . ucfirst($rule['field']); $_input = in_array($getMethod, $methods) ? call_user_func(array($input, $getMethod)) : ''; $arg = (array) $rule['args']; array_unshift($arg, $_input); if (call_user_func_array(array($this->getValidator(), $rule['validator']), $arg) !== false) continue; if ($rule['default'] === null) { $this->_errors[$rule['field']] = $rule['message']; continue; } $setMethod = 'set' . ucfirst($rule['field']); in_array($setMethod, $methods) && call_user_func_array(array($input, $setMethod), array($rule['default'])); } } protected function setValidator($validator) { $this->_validator = $validator; } protected function getValidator() { if ($this->_validator === null) { $_className = Wind::import($this->_validatorClass); $this->_validator = WindFactory::createInstance($_className); if ($this->_validator === null) throw new WindException('validator', WindException::ERROR_RETURN_TYPE_ERROR); } return $this->_validator; } }   class WindErrorMessage extends WindModule implements IWindErrorMessage { private $error = array(); private $errorAction; public function __construct($message = '', $errorAction = '') { $message !== '' && $this->addError($message); $errorAction !== '' && $this->setErrorAction($errorAction); } public function sendError() { if (empty($this->error)) return; throw new WindActionException($this); } public function clearError() { $this->error = array(); } public function getError($key = '') { if ($key === '') return $this->error; return isset($this->error[$key]) ? $this->error[$key] : ''; } public function addError($error, $key = '') { if ($key === '') { if (is_string($error)) $this->error[] = $error; elseif (is_object($error)) $error = get_object_vars($error); if (is_array($error)) $this->error += $error; } else $this->error[$key] = $error; } public function getErrorAction() { return $this->errorAction; } public function setErrorAction($errorAction) { $this->errorAction = $errorAction; } } interface IWindErrorMessage { public function addError($message, $key = ''); public function getError($key = ''); public function clearError(); public function sendError(); }   class WindHelper { const INTERNAL_LOCATION = "~Internal Location~"; public static function errorHandle($errno, $errstr, $errfile, $errline) { if ($errno & error_reporting()) { restore_error_handler(); restore_exception_handler(); $trace = debug_backtrace(); unset($trace[0]["function"], $trace[0]["args"]); self::crash(self::getErrorName($errno) . ':' . $errstr, $errfile, $errline, $trace); exit(); } } public static function exceptionHandle($exception) { restore_error_handler(); restore_exception_handler(); $trace = $exception->getTrace(); if (@$trace[0]['file'] == '') { unset($trace[0]); $trace = array_values($trace); } $file = @$trace[0]['file']; $line = @$trace[0]['line']; self::crash($exception->getMessage(), $file, $line, $trace, $exception->getCode()); exit(); } public static function errorInfo() { $info = "The server encountered an internal error and failed to process your request. Please try again later. If this error is temporary, reloading the page might resolve the problem.\nIf you are able to contact the administrator report this error message."; $info .= "(" . Wind::getApp()->getConfig('siteInfo', '', "http://www.windframework.com/") . ")"; return $info; } protected static function crash($message, $file, $line, $trace, $status = 0) { $errmessage = substr($message, 0, 8000) . "\n"; $_headers = Wind::getApp()->getResponse()->getHeaders(); $_errhtml = false; foreach ($_headers as $_header) { if (strtolower($_header['name']) == strtolower('Content-type')) { $_errhtml = strpos(strtolower($_header['value']), strtolower('text/html')) !== false; break; } } $msg = $msghtml = ''; if (IS_DEBUG) { $errtrace = "__Stack:\n"; $count = count($trace); $padLen = strlen($count); foreach ($trace as $key => $call) { if (!isset($call['file']) || $call['file'] == '') { $call['file'] = self::INTERNAL_LOCATION; $call['line'] = 'N/A'; } $traceLine = '#' . str_pad(($count - $key), $padLen, "0", STR_PAD_LEFT) . '  ' . self::getCallLine( $call); $errtrace .= "$traceLine\n"; } $msg = "$file\n"; $msghtml = "<b style=\"background:whiteSmoke\">$file</b>\n"; if (is_file($file)) { $currentLine = $line - 1; $fileLines = explode("\n", file_get_contents($file, null, null, 0, 10000000)); $topLine = $currentLine - 5; $fileLines = array_slice($fileLines, $topLine > 0 ? $topLine : 0, 10, true); if (($count = count($fileLines)) > 0) { $padLen = strlen($count); foreach ($fileLines as $line => &$fileLine) $fileLine = " " . htmlspecialchars( str_pad($line + 1, $padLen, "0", STR_PAD_LEFT) . ": " . str_replace( "\t", "    ", rtrim($fileLine)), null, "UTF-8"); $msg .= implode("\n", $fileLines) . "\n"; $fileLines[$currentLine] = "<b style=\"color:red; background:whiteSmoke\">" . $fileLines[$currentLine] . "</b>"; $msghtml .= implode("\n", $fileLines) . "\n"; } } $msg .= "$errtrace\n"; $msghtml .= "$errtrace\n"; } $msghtml .= self::errorInfo(); if ($status >= 400 && $status <= 505) { $_statusMsg = ucwords(Wind::getApp()->getResponse()->codeMap($status)); $topic = "$status - " . $_statusMsg . "\n"; header('HTTP/1.x ' . $status . ' ' . $_statusMsg); header('Status: ' . $status . ' ' . $_statusMsg); } else $topic = "Wind Framework - Error Caught\n"; $msghtml = "<html><head><title>$topic</title></head><body><pre><h3>$topic</h3><b style=\"background:whiteSmoke\">$errmessage</b>\n$msghtml</pre></body></html>"; $msg = "$topic\n$errmessage\n$msg"; ob_end_clean(); $msg = str_replace(Wind::getRootPath(Wind::getAppName()), '~', $msg); $msghtml = str_replace(Wind::getRootPath(Wind::getAppName()), '~', $msghtml); Wind::getApp()->getComponent('windLogger')->error($msg, 'wind.error', true); die($_errhtml ? $msghtml : $msg); } private static function getCallLine($call) { $call_signature = ""; if (isset($call['file'])) $call_signature .= $call['file'] . " "; if (isset($call['line'])) $call_signature .= "(" . $call['line'] . ") "; if (isset($call['function'])) { $call_signature .= $call['function'] . "("; if (isset($call['args'])) { foreach ($call['args'] as $arg) { if (is_string($arg)) $arg = '"' . (strlen($arg) <= 64 ? $arg : substr($arg, 0, 64) . "…") . '"'; else if (is_object($arg)) $arg = "[Instance of '" . get_class($arg) . "']"; else if ($arg === true) $arg = "true"; else if ($arg === false) $arg = "false"; else if ($arg === null) $arg = "null"; else $arg = strval($arg); $call_signature .= $arg . ','; } } $call_signature = trim($call_signature, ',') . ")"; } return $call_signature; } protected static function getErrorName($errorNumber) { $errorMap = array(E_ERROR => "E_ERROR", E_WARNING => "E_WARNING", E_PARSE => "E_PARSE", E_NOTICE => "E_NOTICE ", E_CORE_ERROR => "E_CORE_ERROR", E_CORE_WARNING => "E_CORE_WARNING", E_COMPILE_ERROR => "E_COMPILE_ERROR", E_COMPILE_WARNING => "E_COMPILE_WARNING", E_USER_ERROR => "E_USER_ERROR", E_USER_WARNING => "E_USER_WARNING", E_USER_NOTICE => "E_USER_NOTICE", E_STRICT => "E_STRICT", E_RECOVERABLE_ERROR => "E_RECOVERABLE_ERROR", E_ALL => "E_ALL"); return isset($errorMap[$errorNumber]) ? $errorMap[$errorNumber] : 'E_UNKNOWN'; } public static function resolveController($controllerPath) { $_m = $_c = ''; if (!$controllerPath) return array($_c, $_m); if (false !== ($pos = strrpos($controllerPath, '.'))) { $_m = substr($controllerPath, 0, $pos); $_c = substr($controllerPath, $pos + 1); } else { $_c = $controllerPath; } return array($_c, $_m); } }    interface IWindConfigParser { public function parse($configPath, $alias = '', $append = '', AbstractWindCache $cache = null); }  Wind::import('COM:parser.IWindConfigParser'); class WindConfigParser implements IWindConfigParser { const CONFIG_XML = '.XML'; const CONFIG_PHP = '.PHP'; const CONFIG_INI = '.INI'; const CONFIG_PROPERTIES = '.PROPERTIES'; private $configParsers = array(); public function parse($configPath, $alias = '', $append = '', AbstractWindCache $cache = null) { if ($config = $this->getCache($alias, $append, $cache)) return $config; $config = $this->doParser($configPath); $this->setCache($alias, $append, $cache, $config); return $config; } private function setCache($alias, $append, $cache, $data) { if (!$alias || !$cache) return; if ($append) { $_config = (array) $cache->get($append); $_config[$alias] = $data; $cache->set($append, $_config); } else { $cache->set($alias, $data); } } private function getCache($alias, $append, $cache) { if (!$alias || !$cache) return array(); if (!$append) return $cache->get($alias); $config = $cache->get($append); return isset($config[$alias]) ? $config[$alias] : array(); } private function createParser($type) { switch ($type) { case self::CONFIG_XML: Wind::import("WIND:component.parser.WindXmlParser"); return new WindXmlParser(); break; case self::CONFIG_INI: Wind::import("WIND:component.parser.WindIniParser"); return new WindIniParser(); break; case self::CONFIG_PROPERTIES: Wind::import("WIND:component.parser.WindPropertiesParser"); return new WindPropertiesParser(); break; default: throw new WindException('\'ConfigParser\' failed to initialize.'); break; } } private function doParser($configFile) { if (!is_file($configFile)) throw new WindException( '[component.parser.WindConfigParser.doParser] The file \'' . $configFile . '\' is not exists'); $ext = strtoupper(strrchr($configFile, '.')); if ($ext == self::CONFIG_PHP) return @include ($configFile); if (!isset($this->configParsers[$ext])) $this->configParsers[$ext] = $this->createParser($ext); return $this->configParsers[$ext]->parse($configFile); } }   class WindIniParser { protected $separator = '.'; public function parse($filename, $process = true, $build = true) { if (!is_file($filename)) { return array(); } $data = parse_ini_file($filename, $process); return $build ? $this->buildData($data) : $data; } public function buildData(&$data) { foreach ((array)$data as $key => $value) { if (is_array($value)) { $data[$key] = $this->formatDataArray($value); } else { $this->formatDataFromString($key, $value, $data); } } return $data; } public function toArray($key, $value, &$data = array()) { if (empty($key) && empty($value)) return array(); if (strpos($key, $this->separator)) { $start = substr($key, 0, strpos($key, $this->separator)); $end = substr($key, strpos($key, $this->separator) + 1); $data[$start] = array(); $this->toArray($end, $value, $data[$start]); } else { $data[$key] = $value; } return $data; } public function formatDataArray(&$original, &$data = array()) { foreach ((array)$original as $key => $value) { $tmp = $this->toArray($key, $value); foreach ($tmp as $tkey => $tValue) { if (is_array($tValue)) { if (!isset($data[$tkey])) { $data[$tkey] = array(); } $this->formatDataArray($tValue, $data[$tkey]); } else { $data[$tkey] = $tValue; } } } return $data; } public function formatDataFromString($key, $value, &$data) { $tmp = $this->toArray($key, $value); if(false == strpos($key, $this->separator)){ return $tmp; } $start = substr($key, 0, strpos($key, $this->separator)); if ((!isset($data[$start]) || !is_array($data[$start])) && isset($tmp[$start])) { $data[$start] = $tmp[$start]; } else { foreach ($data as $d_key => $d_value) { if (!isset($tmp[$d_key]) || !is_array($tmp[$d_key])) { continue; } foreach ($tmp[$d_key] as $a => $b) { $this->merge($a, $b, $data[$start]); } } } unset($data[$key]); return $data; } private function merge($key, $value, &$data = array()) { if (is_array($value)) { $v_key = array_keys($value); $c_key = $v_key[0]; if (is_array($value[$c_key])) { $this->merge($c_key, $value[$c_key], $data[$key]); } else { $data[$key][$c_key] = $value[$c_key]; } } else { $data[$key] = $value; } return $data; } }   class WindPropertiesParser { const COMMENT = '#'; const LPROCESS = '['; const RPROCESS = ']'; private $separator = '.'; public function __construct() { } public function parse($filename, $process = true, $build = true) { $data = $this->parse_properties_file($filename, $process); return $build ? $this->buildData($data) : $data; } private function delComment($filename, $process) { } public function parse_properties_file($filename, $process = true) { if (!is_file($filename) || !in_array(substr($filename, strrpos($filename, '.') + 1), array('properties'))) { return array(); } $fp = fopen($filename, 'r'); $content = fread($fp, filesize($filename)); fclose($fp); $content = explode("\n", $content); $data = array(); $last_process = $current_process = ''; foreach ($content as $key => $value) { $value = str_replace(array("\n", "\r"), '', trim($value)); if (0 === strpos(trim($value), self::COMMENT) || in_array(trim($value), array('', "\t", "\n"))) { continue; } $tmp = explode('=', $value, 2); if (0 === strpos(trim($value), self::LPROCESS) && (strlen($value) - 1) === strrpos($value, self::RPROCESS)) { if ($process) { $current_process = $this->trimChar(trim($value), array(self::LPROCESS, self::RPROCESS)); $data[$current_process] = array(); $last_process = $current_process; } continue; } $tmp[0] = trim($tmp[0]); $tmp[1] = trim($tmp[1], '\'"'); if ($last_process) { count($tmp) > 1 ? $data[$last_process][$tmp[0]] = $tmp[1] : $data[$last_process][$tmp[0]] = ''; } else { count($tmp) > 1 ? $data[$tmp[0]] = $tmp[1] : $data[$tmp[0]] = ''; } } return $data; } public function buildData(&$data) { foreach ((array)$data as $key => $value) { if (is_array($value)) { $data[$key] = $this->formatDataArray($value); } else { $this->formatDataFromString($key, $value, $data); } } return $data; } public function toArray($key, $value, &$data = array()) { if (empty($key) && empty($value)) return array(); if (strpos($key, $this->separator)) { $start = substr($key, 0, strpos($key, $this->separator)); $end = substr($key, strpos($key, $this->separator) + 1); $data[$start] = array(); $this->toArray($end, $value, $data[$start]); } else { $data[$key] = $value; } return $data; } public function formatDataArray(&$original, &$data = array()) { foreach ((array)$original as $key => $value) { $tmp = $this->toArray($key, $value); foreach ($tmp as $tkey => $tValue) { if (is_array($tValue)) { if (!isset($data[$tkey])) { $data[$tkey] = array(); } $this->formatDataArray($tValue, $data[$tkey]); } else { $data[$tkey] = $tValue; } } } return $data; } public function formatDataFromString($key, $value, &$data) { $tmp = $this->toArray($key, $value); if(false == strpos($key, $this->separator)){ return $tmp; } $start = substr($key, 0, strpos($key, $this->separator)); if ((!isset($data[$start]) || !is_array($data[$start])) && isset($tmp[$start])) { $data[$start] = $tmp[$start]; } else { foreach ($data as $d_key => $d_value) { if (!isset($tmp[$d_key]) || !is_array($tmp[$d_key])) { continue; } foreach ($tmp[$d_key] as $a => $b) { $this->merge($a, $b, $data[$start]); } } } unset($data[$key]); return $data; } private function merge($key, $value, &$data = array()) { if (is_array($value)) { $v_key = array_keys($value); $c_key = $v_key[0]; if (is_array($value[$c_key])) { $this->merge($c_key, $value[$c_key], $data[$key]); } else { $data[$key][$c_key] = $value[$c_key]; } } else { $data[$key] = $value; } return $data; } private function trimChar($str, $char = ' ') { $char = is_array($char) ? $char : array($char); foreach ($char as $value) { $str = trim($str, $value); } return $str; } }   class WindXmlParser { const NAME = 'name'; private $dom = null; public function __construct($version = '1.0', $encode = 'utf-8') { if (!class_exists('DOMDocument')) throw new WindException('DOMDocument is not exist.'); $this->dom = new DOMDocument($version, $encode); } public function parse($filename, $option = null) { if (!is_file($filename)) return array(); $this->dom->load($filename, $option); return $this->getChilds($this->dom->documentElement); } public function getChilds($node) { if (!$node instanceof DOMElement) return array(); $childs = array(); foreach ($node->childNodes as $node) { $tempChilds = $attributes = array(); ($node->hasAttributes()) && $attributes = $this->getAttributes($node); (3 == $node->nodeType && trim($node->nodeValue)) && $childs[0] = (string) $node->nodeValue; if (1 !== $node->nodeType) continue; $nodeName = ($name = $node->getAttribute(self::NAME)) ? $name : $node->nodeName; $tempChilds = $this->getChilds($node); $tempChilds = array_merge($attributes, $tempChilds); if (empty($tempChilds)) $tempChilds = ''; $tempChilds = (isset($tempChilds[0]) && count($tempChilds) == 1) ? $tempChilds[0] : $tempChilds; if (!isset($childs[$nodeName])) { $childs[$nodeName] = $tempChilds; continue; } else { $element = $childs[$nodeName]; $childs[$nodeName] = (is_array($element) && !is_numeric(implode('', array_keys($element)))) ? array_merge(array( $element), array($tempChilds)) : array_merge((array) $element, array($tempChilds)); continue; } } return $childs; } public function getAttributes($node) { if (!$node instanceof DOMElement || !$node->hasAttributes()) return array(); $attributes = array(); foreach ($node->attributes as $attribute) { if (self::NAME != $attribute->nodeName) { $attributes[$attribute->nodeName] = (string) $attribute->nodeValue; } } return $attributes; } }    abstract class AbstractWindRouter extends WindHandlerInterceptorChain { protected $moduleKey = 'm'; protected $controllerKey = 'c'; protected $actionKey = 'a'; protected $module; protected $controller = 'index'; protected $action = 'run'; protected $currentRoute = null; abstract public function route(); abstract public function assemble(); public function setConfig($config) { parent::setConfig($config); if ($this->_config) { $this->module = $this->getConfig('module', 'default-value', $this->module); $this->controller = $this->getConfig('controller', 'default-value', $this->controller); $this->action = $this->getConfig('action', 'default-value', $this->action); $this->moduleKey = $this->getConfig('module', 'url-param', $this->moduleKey); $this->controllerKey = $this->getConfig('controller', 'url-param', $this->controllerKey); $this->actionKey = $this->getConfig('action', 'url-param', $this->actionKey); } } protected function setParams($params) { foreach ($params as $key => $value) { if ($this->actionKey === $key) $this->setAction($value); elseif ($this->controllerKey === $key) $this->setController($value); elseif ($this->moduleKey === $key) $this->setModule($value); else { $this->getRequest()->setAttribute($value, $key); } } } public function addRoute($routeInstance, $current = false) { if ($current) $this->currentRoute = $routeInstance; $this->addInterceptors($routeInstance); } public function getAction() { return $this->action; } public function getController() { return $this->controller; } public function setAction($action) { $this->action = $action; } public function setController($controller) { $this->controller = $controller; } public function getModule() { return $this->module; } public function setModule($module) { $this->module = $module; } public function getModuleKey() { return $this->moduleKey; } public function getControllerKey() { return $this->controllerKey; } public function getActionKey() { return $this->actionKey; } public function setModuleKey($moduleKey) { $this->moduleKey = $moduleKey; } public function setControllerKey($controllerKey) { $this->controllerKey = $controllerKey; } public function setActionKey($actionKey) { $this->actionKey = $actionKey; } }   abstract class AbstractWindRoute extends WindHandlerInterceptor { abstract public function build(); abstract public function match(); public function handle() { $args = func_get_args(); $this->result = call_user_func_array(array($this, 'match'), $args); if ($this->result !== null) { return $this->result; } if (null !== ($handler = $this->interceptorChain->getHandler())) { $this->result = call_user_func_array(array($handler, 'handle'), $args); } else { $this->result = $this->interceptorChain->execute(); } call_user_func_array(array($this, 'postHandle'), $args); return $this->result; } }   Wind::import('COM:router.route.AbstractWindRoute'); class WindRewriteRoute extends AbstractWindRoute { public function build() { } public function match() { } }    class WindRoute extends AbstractWindRoute { protected $params = array(); protected $pattern; protected $reverse; public function match() { } public function build() { } public function setConfig($config) { parent::setConfig($config); $this->setParams($this->getConfig('params')); $this->setPattern($this->getConfig('pattern')); $this->setReverse($this->getConfig('reverse')); } }   Wind::import('COM:router.AbstractWindRouter'); class WindRouter extends AbstractWindRouter { public function route() { $this->setCallBack(array($this, 'defaultRoute')); $params = $this->getHandler()->handle(); $this->setParams($params); } public function assemble() { } public function defaultRoute() { $params[$this->actionKey] = $this->getRequest()->getRequest($this->actionKey, $this->action); $params[$this->controllerKey] = $this->getRequest()->getRequest($this->controllerKey, $this->controller); $params[$this->moduleKey] = $this->getRequest()->getRequest($this->moduleKey, $this->module); return $params; } }    Wind::import('COM:router.AbstractWindRouter'); class WindUrlRewriteRouter extends AbstractWindRouter { private $urlPatttern = ''; private $keyValueSep = ''; private $separator = ''; private $suffix = ''; private $isRewrite = 0; private $keyPrefix = ''; private $baseUrl = ''; private $patterns = array(); public function isRewrite() { return $this->isRewrite == '1' || $this->isRewrite == 'true'; } public function parse() { $this->isRewrite() && $this->parseUrl(); $this->setModule($this->getUrlParamValue('module', $this->getModule())); $this->setController($this->getUrlParamValue('controller', $this->getController())); $this->setAction($this->getUrlParamValue('action', $this->getAction())); } public function parseUrl() { if (!$this->isRewrite()) return; $url = array(); if ($this->getRequest()->getServer('SERVER_PROTOCOL')) { $pathInfo = $this->getRequest()->getServer('PATH_INFO'); if ($pathInfo && !empty($pathInfo)) { $url = rtrim($pathInfo, $this->suffix); } elseif ('' != ($url = $this->getRequest()->getRequestUri())) { $scriptName = $this->getRequest()->getScriptUrl(); if (0 === strpos($url, $scriptName)) { $url = substr($url, strlen($scriptName)); } $url = rtrim($url, $this->suffix); } $url = trim($url, '?/'); $url && $params = $this->doParserUrl($url); } else { $i = 0; $args = $this->getRequest()->getServer('argv', array()); while (isset($args[$i]) && isset($args[$i + 1])) { $params[$args[$i]] = $args[$i + 1]; $i += 2; } } foreach ($params as $k => $v) { !isset($_GET[$k]) && $_GET[$k] = $v; } } public function buildUrl($action = '', $controller = '', $params = array()) { list($module, $controller, $action) = $this->resolveMvc($action, $controller); $m = $this->getConfig('module', 'url-param'); $c = $this->getConfig('controller', 'url-param'); $a = $this->getConfig('action', 'url-param'); $params = array_merge(array($m => $module, $c => $controller, $a => $action), $params); return $this->isRewrite() ? $this->buildRewriteUrl($params) : $this->baseUrl . '/index.php?' . http_build_query( $params, '', '&'); } private function resolveMvc($action, $controller) { list($controller, $module) = WindHelper::resolveController($controller); !$module && $module = $this->getConfig('module', 'default-value'); !$controller && $controller = $this->getConfig('controller', 'default-value'); !$action && $action = $this->getConfig('action', 'default-value'); return array($module, $controller, $action); } private function buildRewriteUrl($params) { $url = $this->urlPatttern; foreach ($this->patterns as $key => $value) { if ('*' == $value[0]) { $url = str_replace($value, $this->buildNomalKeys($params), $url); } else { $url = $this->buildVars($value, $params, $url); } } return $this->baseUrl . '/' . $url . $this->suffix; } private function buildVars($value, &$params, $url) { $keys = explode($this->keyValueSep, $value); $values = array(); foreach ($keys as $v) { if (!isset($params[$v])) continue; $values[] = $params[$v]; unset($params[$v]); } return str_replace($keys, $values, $url); } private function buildNomalKeys($params, $parentKey = '', $first = true) { $tmp = array(); foreach ($params as $k => $v) { if (is_int($k) && $this->keyPrefix != null && $first) { $k = urlencode($this->keyPrefix . $k); } if (!empty($parentKey)) $k = $parentKey . '[' . $k . ']'; if (is_array($v)) { array_push($tmp, $this->buildNomalKeys($v, $k, false)); } else { array_push($tmp, $k . $this->keyValueSep . urlencode($v)); } } return implode($this->separator, $tmp); } private function doParserUrl($url) { if (!$url) return array(); if (is_string($url)) { $url = explode($this->separator, trim($url, $this->separator)); } $vars = array(); foreach ($this->patterns as $key => $value) { if ('*' == $value[0]) $this->parseNomalKeys($key, $url, $vars); else { if (!isset($url[$key])) continue; if (false === strrpos($value, $this->keyValueSep)) { $vars[$value] = $url[$key]; continue; } $keys = explode($this->keyValueSep, $value); $values = explode($this->keyValueSep, $url[$key]); foreach ($keys as $pos => $key) { isset($values[$pos]) && $vars[$key] = $values[$pos]; } } } return $vars; } private function parseNomalKeys($key, $urlParams, &$params) { $pos = 0; while (isset($urlParams[$key])) { if ($this->separator == $this->keyValueSep) { if (isset($urlParams[$key + 1])) { $this->parseKey($params, $urlParams[$key], urldecode($urlParams[$key + 1])); $key += 2; } continue; } if (false === strrpos($urlParams[$key], $this->keyValueSep)) { $params[$this->keyPrefix . $pos] = urldecode($urlParams[$key]); $pos++; } else { list($k, $v) = explode($this->keyValueSep, $urlParams[$key], 2); $this->parseKey($params, $k, urldecode($v)); } $key += 1; } } private function parseKey(&$params, $key, $value) { if (($pos = strpos($key, '[')) === false || ($pos2 = strpos($key, ']', $pos + 1)) === false) { $params[$key] = $value; return; } $name = substr($key, 0, $pos); if ($pos2 === $pos + 1) { $params[$name][] = $value; return; } else { $key = substr($key, $pos + 1, $pos2 - $pos - 1); $params[$name][$key] = $value; return; } } public function setConfig($config) { $usrConfig = $this->getSystemConfig()->getConfig('router', 'config'); $usrConfig && $config = array_merge($config, $usrConfig); parent::setConfig($config); $this->urlPatttern = $this->getConfig('url-pattern'); $this->separator = $this->getConfig('separator'); $this->keyValueSep = $this->getConfig('key-value-sep'); $this->keyValueSep == "" && $this->keyValueSep = $this->separator; $this->suffix = '.' . trim($this->getConfig('suffix'), '.'); $this->isRewrite = $this->getConfig('is-rewrite'); $this->keyPrefix = $this->getConfig('key-prefix'); $this->patterns = explode($this->separator, trim($this->urlPatttern, $this->separator)); $this->baseUrl = rtrim($this->getRequest()->getBaseUrl(true), '/'); if (!$this->isRewrite()) $this->baseUrl = $this->baseUrl . $this->getRequest()->getScriptUrl(); } private function getUrlParamValue($type, $defaultValue = '') { if ($_param = $this->getConfig($type, 'url-param')) { $_defaultValue = $this->getConfig($type, 'default-value', $defaultValue); $tmp = $this->getRequest()->getRequest($_param, $defaultValue); return !$tmp ? $defaultValue : $tmp; } return $defaultValue; } public function route() { } public function assemble() { } }    class WindCookie{ public static function set($name, $value=null, $expires = null,$encode = false,$serialize = false,$prefix=null ,$path = null,$domain =null,$secure = false,$httponly=false){ if(empty($name)){ return false; } $name = $prefix ? $prefix.$name : $name; $value = $serialize ? serialize($value) : $value; $value = $encode ? base64_encode($value) : $value; $path = $path ? $path : '/'; $expires = is_int($expires) ? time()+$expires : strtotime($expires); setcookie($name,$value,$expires,$path,$domain,$secure,$httponly); return true; } public static function remove($name,$prefix=null){ $name = $prefix ? $prefix.$name : $name; if(self::exist($name)){ self::set($name,'',time()-3600); unset($_COOKIE[$name]); } return true; } public static function get($name,$encode = false,$serialize = false,$prefix=null){ $name = $prefix ? $prefix.$name : $name; if(self::exist($name)){ $value = get_magic_quotes_gpc() ? stripslashes($_COOKIE[$name]) : $_COOKIE[$name]; $value = $encode ? base64_decode($value):$value; return $serialize ? unserialize($value) : $value; } return false; } public static function removeAll(){ $_COOKIE = array(); } public static function exist($name,$prefix=null){ return isset($_COOKIE[$prefix ? $prefix.$name : $name]); } }   class WindCookieObject{ public $prefix; protected $name; protected $value; protected $expires; protected $domain; protected $path; protected $secure; protected $encode; protected $httponly; public function __construct($name, $value=null, $expires = null, $path = null,$domain =null, $secure = false,$httponly=false,$prefix=null,$encode = false){ $this->name = (string) $name; $this->value = (string) $value; $this->domain = (string) $domain; $this->expires = (null === $expires ? null : (int) $expires); $this->path = ($path ? $path : '/'); $this->secure = $secure; $this->httponly = $httponly; $this->prefix = (string)$prefix; $this->encode = $encode; } public function getName(){ return $this->prefix ? $this->prefix.$this->name : $this->prefix; } public function getValue(){ return $this->value; } public function getDomain(){ return $this->domain; } public function getPath(){ return $this->path; } public function getExpirs(){ return $this->expires; } public function isSecure(){ return $this->secure; } public function isExpired($now = null){ return (is_int($this->expires) && $this->expires < ($now ? $now : time())) ? true : false; } public function isSessionCookie(){ return null === $this->expires; } public function __toString(){ return $this->name . '='. ($this->encode ? urlencode($this->value) : $this->value) .';'; } public static function getCookieFromString($cookiestr,$prefix = null,$encode = false){ $cookie = explode(';',$cookiestr); list($name,$value) = explode('=',array_shift($cookie)); if(empty($name)){ return null; } $domain=$expires =$path = null; $httponly = $secure = false; foreach($cookie as $_cookie){ list($key,$_value) = explode('=',$_cookie); switch($key){ case 'domain':$domain=$_value;break; case 'path':$path=$_value;break; case 'expires':$expires = is_int($_value) ? $_value : strtotime($_value);break; case 'httponly':$httponly=(bool)$_value;break; case 'secure':$secure=(bool)$_value;break; } } return new self($name,$value,$expires,$path,$domain,$secure,$httponly,$prefix,$encode); } }   interface IWindRequest { const INPUT_TYPE_GET = 'get'; const INPUT_TYPE_POST = 'post'; const INPUT_TYPE_COOKIE = 'cookie'; }   Wind::import('COM:http.request.IWindRequest'); class WindHttpRequest implements IWindRequest { private $_port = null; private $_clientIp = null; private $_language = null; private $_pathInfo = null; private $_scriptUrl = null; private $_requestUri = null; private $_baseUrl = null; private $_hostInfo = null; private $_attribute = array(); private $_response = null; public function __construct() { $this->normalizeRequest(); } protected function normalizeRequest() { if (function_exists('get_magic_quotes_gpc') && get_magic_quotes_gpc()) { if (isset($_GET)) $_GET = $this->stripSlashes($_GET); if (isset($_POST)) $_POST = $this->stripSlashes($_POST); if (isset($_REQUEST)) $_REQUEST = $this->stripSlashes($_REQUEST); if (isset($_COOKIE)) $_COOKIE = $this->stripSlashes($_COOKIE); } } public function stripSlashes(&$data) { return is_array($data) ? array_map(array($this, 'stripSlashes'), $data) : stripslashes( $data); } public function setAttribute($data, $key = '') { if ($key) { $this->_attribute[$key] = $data; return; } if (is_object($data)) $data = get_object_vars($data); if (is_array($data)) $this->_attribute = array_merge($this->_attribute, $data); } public function getAttribute($key, $defaultValue = '') { if (isset($this->_attribute[$key])) return $this->_attribute[$key]; else if (isset($_GET[$key])) return $_GET[$key]; else if (isset($_POST[$key])) return $_POST[$key]; else if (isset($_COOKIE[$key])) return $_COOKIE[$key]; else if (isset($_REQUEST[$key])) return $_REQUEST[$key]; else if (isset($_ENV[$key])) return $_ENV[$key]; else if (isset($_SERVER[$key])) return $_SERVER[$key]; else return $defaultValue; } public function getRequest($key = null, $defaultValue = null) { if (!$key) return array_merge($_POST, $_GET); if (isset($_GET[$key])) return $_GET[$key]; if (isset($_POST[$key])) return $_POST[$key]; return $defaultValue; } public function getQuery($name = null, $defaultValue = null) { return $this->getGet($name, $defaultValue); } public function getPost($name = null, $defaultValue = null) { if ($name == null) return $_POST; return isset($_POST[$name]) ? $_POST[$name] : $defaultValue; } public function getGet($name = '', $defaultValue = null) { if ($name == null) return $_GET; return (isset($_GET[$name])) ? $_GET[$name] : $defaultValue; } public function getCookie($name = null, $defaultValue = null) { if ($name == null) return $_COOKIE; return (isset($_COOKIE[$name])) ? $_COOKIE[$name] : $defaultValue; } public function getSession($name = null, $defaultValue = null) { if ($name == null) return $_SESSION; return (isset($_SESSION[$name])) ? $_SESSION[$name] : $defaultValue; } public function getServer($name = null, $defaultValue = null) { if ($name == null) return $_SERVER; return (isset($_SERVER[$name])) ? $_SERVER[$name] : $defaultValue; } public function getEnv($name = null, $defaultValue = null) { if ($name == null) return $_ENV; return (isset($_ENV[$name])) ? $_ENV[$name] : $defaultValue; } public function getScheme() { return ($this->getServer('HTTPS') == 'on') ? 'https' : 'http'; } public function getProtocol() { return $this->getServer('SERVER_PROTOCOL', 'HTTP/1.0'); } public function getClientIp() { if (!$this->_clientIp) $this->_getClientIp(); return $this->_clientIp; } public function getRequestMethod() { return strtoupper($this->getServer('REQUEST_METHOD')); } public function getRequestType() { return IWindRequest::REQUEST_TYPE_WEB; } public function getIsAjaxRequest() { return !strcasecmp($this->getServer('HTTP_X_REQUESTED_WITH'), 'XMLHttpRequest'); } public function isSecure() { return !strcasecmp($this->getServer('HTTPS'), 'on'); } public function isGet() { return !strcasecmp($this->getRequestMethod(), 'GET'); } public function isPost() { return !strcasecmp($this->getRequestMethod(), 'POST'); } public function isPut() { return !strcasecmp($this->getRequestMethod(), 'PUT'); } public function isDelete() { return !strcasecmp($this->getRequestMethod(), 'Delete'); } public function getRequestUri() { if (!$this->_requestUri) $this->_initRequestUri(); return $this->_requestUri; } public function getScriptUrl() { if (!$this->_scriptUrl) $this->_initScriptUrl(); return $this->_scriptUrl; } public function getScript() { if (($pos = strrpos($this->getScriptUrl(), '/')) === false) $pos = -1; return substr($this->getScriptUrl(), $pos + 1); } public function getHeader($header, $default = null) { $temp = strtoupper(str_replace('-', '_', $header)); if (substr($temp, 0, 5) != 'HTTP_') $temp = 'HTTP_' . $temp; if (($header = $this->getServer($temp)) != null) return $header; if (function_exists('apache_request_headers')) { $headers = apache_request_headers(); if ($headers[$header]) return $headers[$header]; } return $default; } public function getPathInfo() { if (!$this->_pathInfo) $this->_initPathInfo(); return $this->_pathInfo; } public function getBaseUrl($absolute = false) { if ($this->_baseUrl === null) $this->_baseUrl = rtrim(dirname($this->getScriptUrl()), '\\/.'); return $absolute ? $this->getHostInfo() . $this->_baseUrl : $this->_baseUrl; } public function getHostInfo() { if ($this->_hostInfo === null) $this->_initHostInfo(); return $this->_hostInfo; } public function getServerName() { return $this->getServer('SERVER_NAME', ''); } public function getServerPort() { if (!$this->_port) { $_default = $this->isSecure() ? 443 : 80; $this->setServerPort($this->getServer('SERVER_PORT', $_default)); } return $this->_port; } public function setServerPort($port) { $this->_port = (int) $port; } public function getRemoteHost() { return $this->getServer('REMOTE_HOST'); } public function getUrlReferer() { return $this->getServer('HTTP_REFERER'); } public function getRemotePort() { return $this->getServer('REMOTE_PORT'); } public function getUserAgent() { return $this->getServer('HTTP_USER_AGENT', ''); } public function getAcceptTypes() { return $this->getServer('HTTP_ACCEPT', ''); } public function getAcceptCharset() { return $this->getServer('HTTP_ACCEPT_ENCODING', ''); } public function getAcceptLanguage() { if (!$this->_language) { $_language = explode(',', $this->getServer('HTTP_ACCEPT_LANGUAGE', '')); $this->_language = $_language[0] ? $_language[0] : 'zh-cn'; } return $this->_language; } public function getResponse($charset) { $response = new WindHttpResponse(); !$charset && $charset = 'utf-8'; $response->setHeader('Content-type', 'text/html;charset=' . $charset); $response->setCharset($charset); return $response; } private function _getClientIp() { if (($ip = $this->getServer('HTTP_CLIENT_IP')) != null) { $this->_clientIp = $ip; } elseif (($_ip = $this->getServer('HTTP_X_FORWARDED_FOR')) != null) { $ip = strtok($_ip, ','); do { $ip = ip2long($ip); if (!(($ip == 0) || ($ip == 0xFFFFFFFF) || ($ip == 0x7F000001) || (($ip >= 0x0A000000) && ($ip <= 0x0AFFFFFF)) || (($ip >= 0xC0A8FFFF) && ($ip <= 0xC0A80000)) || (($ip >= 0xAC1FFFFF) && ($ip <= 0xAC100000)))) { $this->_clientIp = long2ip($ip); return; } } while (($ip = strtok(','))); } elseif (($ip = $this->getServer('HTTP_PROXY_USER')) != null) { $this->_clientIp = $ip; } elseif (($ip = $this->getServer('REMOTE_ADDR')) != null) { $this->_clientIp = $ip; } else { $this->_clientIp = "0.0.0.0"; } } private function _initRequestUri() { if (($requestUri = $this->getServer('HTTP_X_REWRITE_URL')) != null) { $this->_requestUri = $requestUri; } elseif (($requestUri = $this->getServer('REQUEST_URI')) != null) { $this->_requestUri = $requestUri; if (strpos($this->_requestUri, $this->getServer('HTTP_HOST')) !== false) $this->_requestUri = preg_replace('/^\w+:\/\/[^\/]+/', '', $this->_requestUri); } elseif (($requestUri = $this->getServer('ORIG_PATH_INFO')) != null) { $this->_requestUri = $requestUri; if (($query = $this->getServer('QUERY_STRING')) != null) $this->_requestUri .= '?' . $query; } else throw new WindException(__CLASS__ . ' is unable to determine the request URI.'); } private function _initScriptUrl() { if (($scriptName = $this->getServer('SCRIPT_FILENAME')) == null) throw new WindException(__CLASS__ . ' determine the entry script URL failed!!!'); $scriptName = basename($scriptName); if (($_scriptName = $this->getServer('SCRIPT_NAME')) != null && basename($_scriptName) === $scriptName) { $this->_scriptUrl = $_scriptName; } elseif (($_scriptName = $this->getServer('PHP_SELF')) != null && basename($_scriptName) === $scriptName) { $this->_scriptUrl = $_scriptName; } elseif (($_scriptName = $this->getServer('ORIG_SCRIPT_NAME')) != null && basename( $_scriptName) === $scriptName) { $this->_scriptUrl = $_scriptName; } elseif (($pos = strpos($this->getServer('PHP_SELF'), '/' . $scriptName)) !== false) { $this->_scriptUrl = substr($this->getServer('SCRIPT_NAME'), 0, $pos) . '/' . $scriptName; } elseif (($_documentRoot = $this->getServer('DOCUMENT_ROOT')) != null && ($_scriptName = $this->getServer( 'SCRIPT_FILENAME')) != null && strpos($_scriptName, $_documentRoot) === 0) { $this->_scriptUrl = str_replace('\\', '/', str_replace($_documentRoot, '', $_scriptName)); } else throw new WindException(__CLASS__ . ' determine the entry script URL failed!!'); } private function _initHostInfo() { $http = $this->isSecure() ? 'https' : 'http'; if (($httpHost = $this->getServer('HTTP_HOST')) != null) $this->_hostInfo = $http . '://' . $httpHost; elseif (($httpHost = $this->getServer('SERVER_NAME')) != null) { $this->_hostInfo = $http . '://' . $httpHost; if (($port = $this->getServerPort()) != null) $this->_hostInfo .= ':' . $port; } else throw new WindException(__CLASS__ . ' determine the entry script URL failed!!'); } private function _initPathInfo() { $requestUri = urldecode($this->getRequestUri()); $scriptUrl = $this->getScriptUrl(); $baseUrl = $this->getBaseUrl(); if (strpos($requestUri, $scriptUrl) === 0) $pathInfo = substr($requestUri, strlen($scriptUrl)); elseif ($baseUrl === '' || strpos($requestUri, $baseUrl) === 0) $pathInfo = substr($requestUri, strlen($baseUrl)); elseif (strpos($_SERVER['PHP_SELF'], $scriptUrl) === 0) $pathInfo = substr($_SERVER['PHP_SELF'], strlen($scriptUrl)); else throw new WindException(__CLASS__ . ' determine the entry path info failed!!'); if (($pos = strpos($pathInfo, '?')) !== false) $pathInfo = substr($pathInfo, $pos + 1); $this->_pathInfo = trim($pathInfo, '/'); } }   interface IWindResponse { }  Wind::import('COM:http.response.IWindResponse'); class WindHttpResponse implements IWindResponse { private $_body = array(); private $_bodyIndex = array(); private $_charset = 'utf-8'; private $_headers = array(); private $_isRedirect = false; private $_status = ''; private $_data = array('G' => array()); const W_CONTINUE = 100; const W_SWITCHING_PROTOCOLS = 101; const W_OK = 200; const W_CREATED = 201; const W_ACCEPTED = 202; const W_NON_AUTHORITATIVE_INFORMATION = 203; const W_NO_CONTENT = 204; const W_RESET_CONTENT = 205; const W_PARTIAL_CONTENT = 206; const W_MULTIPLE_CHOICES = 300; const W_MOVED_PERMANENTLY = 301; const W_MOVED_TEMPORARILY = 302; const W_FOUND = 302; const W_SEE_OTHER = 303; const W_NOT_MODIFIED = 304; const W_USE_PROXY = 305; const W_TEMPORARY_REDIRECT = 307; const W_BAD_REQUEST = 400; const W_UNAUTHORIZED = 401; const W_PAYMENT_REQUIRED = 402; const W_FORBIDDEN = 403; const W_NOT_FOUND = 404; const W_METHOD_NOT_ALLOWED = 405; const W_NOT_ACCEPTABLE = 406; const W_PROXY_AUTHENTICATION_REQUIRED = 407; const W_REQUEST_TIMEOUT = 408; const W_CONFLICT = 409; const W_GONE = 410; const W_LENGTH_REQUIRED = 411; const W_PRECONDITION_FAILED = 412; const W_REQUEST_ENTITY_TOO_LARGE = 413; const W_REQUEST_URI_TOO_LONG = 414; const W_UNSUPPORTED_MEDIA_TYPE = 415; const W_REQUESTED_RANGE_NOT_SATISFIABLE = 416; const W_EXPECTATION_FAILED = 417; const W_INTERNAL_SERVER_ERROR = 500; const W_NOT_IMPLEMENTED = 501; const W_BAD_GATEWAY = 502; const W_SERVICE_UNAVAILABLE = 503; const W_GATEWAY_TIMEOUT = 504; const W_HTTP_VERSION_NOT_SUPPORTED = 505; public function codeMap($code) { $map = array(505 => 'http version not supported', 504 => 'gateway timeout', 503 => 'service unavailable', 503 => 'bad gateway', 502 => 'bad gateway', 501 => 'not implemented', 500 => 'internal server error', 417 => 'expectation failed', 416 => 'requested range not satisfiable', 415 => 'unsupported media type', 414 => 'request uri too long', 413 => 'request entity too large', 412 => 'precondition failed', 411 => 'length required', 410 => 'gone', 409 => 'conflict', 408 => 'request timeout', 407 => 'proxy authentication required', 406 => 'not acceptable', 405 => 'method not allowed', 404 => 'not found', 403 => 'forbidden', 402 => 'payment required', 401 => 'unauthorized', 400 => 'bad request', 300 => 'multiple choices', 301 => 'moved permanently', 302 => 'moved temporarily', 302 => 'found', 303 => 'see other', 304 => 'not modified', 305 => 'use proxy', 307 => 'temporary redirect', 100 => 'continue', 101 => 'witching protocols', 200 => 'ok', 201 => 'created', 202 => 'accepted', 203 => 'non authoritative information', 204 => 'no content', 205 => 'reset content', 206 => 'partial content'); return isset($map[$code]) ? $map[$code] : ''; } public function setHeader($name, $value, $replace = false) { if (!$name || !$value) return; $name = $this->_normalizeHeader($name); $setted = false; foreach ($this->_headers as $key => $one) { if ($one['name'] == $name) { $this->_headers[$key] = array('name' => $name, 'value' => $value, 'replace' => $replace); $setted = true; break; } } if ($setted === false) $this->_headers[] = array('name' => $name, 'value' => $value, 'replace' => $replace); } public function addHeader($name, $value, $replace = false) { if ($name == '' || $value == '') return; $name = $this->_normalizeHeader($name); $this->_headers[] = array('name' => $name, 'value' => $value, 'replace' => $replace); } public function getCharset() { return $this->_charset; } public function setCharset($_charset) { $this->_charset = $_charset; } public function setStatus($status, $message = '') { $status = intval($status); if ($status < 100 || $status > 505) return; $this->_status = (int) $status; } public function setBody($content, $name = null) { if (!$content) return; !$name && $name = 'default'; array_push($this->_bodyIndex, $name); $this->_body[$name] = $content; } public function addCookie(Cookie $cookie) { } public function sendError($status = self::W_NOT_FOUND, $message = '') { if (!is_int($status) || $status < 400 || $status > 505) return; $this->setBody($message, 'error'); $this->setStatus($status); $this->sendResponse(); } public function sendRedirect($location, $status = 302) { if (!is_int($status) || $status < 300 || $status > 399) return; $this->addHeader('Location', $location, true); $this->setStatus($status); $this->_isRedirect = true; $this->sendHeaders(); exit(); } public function sendResponse() { $this->sendHeaders(); $this->sendBody(); } public function sendHeaders() { if ($this->isSendedHeader()) return; foreach ($this->_headers as $header) { header($header['name'] . ': ' . $header['value'], $header['replace']); } if ($this->_status) { header('HTTP/1.x ' . $this->_status . ' ' . ucwords($this->codeMap($this->_status))); header('Status: ' . $this->_status . ' ' . ucwords($this->codeMap($this->_status))); } } public function sendBody() { foreach ($this->_bodyIndex as $key) echo $this->_body[$key]; } public function getBody($name = false) { if ($name === false) { ob_start(); $this->sendBody(); return ob_get_clean(); } elseif ($name === true) { return $this->_body; } elseif (is_string($name) && isset($this->_body[$name])) return $this->_body[$name]; return null; } public function isSendedHeader($throw = false) { $sended = headers_sent($file, $line); if ($throw && $sended) throw new WindException( __CLASS__ . ' the headers are sent in file ' . $file . ' on line ' . $line); return $sended; } public function getHeaders() { return $this->_headers; } public function clearBody() { $this->_body = array(); } public function clearHeaders() { $this->_headers = array(); } private function _normalizeHeader($name) { $filtered = str_replace(array('-', '_'), ' ', (string) $name); $filtered = ucwords(strtolower($filtered)); $filtered = str_replace(' ', '-', $filtered); return $filtered; } public function getData($key1 = '', $key2 = '') { if (!$key1) return $this->_data; if (!$key2) return isset($this->_data[$key1]) ? $this->_data[$key1] : ''; return isset($this->_data[$key1]) ? (isset($this->_data[$key1][$key2]) ? $this->_data[$key1][$key2] : '') : ''; } public function setData($data, $key = '', $isG = false) { if ($key) { if ($isG) $this->_data['G'][$key] = $data; else $this->_data[$key] = $data; return; } if (is_object($data)) $data = get_object_vars($data); if (is_array($data)) { if ($isG) $this->_data['G'] += $data; else $this->_data += $data; } } }   abstract class AbstractWindUserSession { public static abstract function open($savePath, $sessionName); public static abstract function close(); public static abstract function write($name,$value); public static abstract function read($name); public static abstract function gc($maxlifetime); public static abstract function destroy($name); public static function callUserSessionHandler(){ $className = get_class($this); session_set_save_handler(array($className,'open'),array($className,'close'),array($className,'read'),array($className,'write'),array($className,'destroy'),array($className,'gc')); } }    Wind::import('WIND:component.http.session.AbstractWindUserSession'); class WindDbSession extends AbstractWindUserSession { public static function open($savePath, $sessionName){ return true; } public static function close(){ return true; } public static function write($name,$value){ } public static function read($name){ } public static function gc($maxlifetime){ } public static function destroy($name){ } }    class WindSession implements IteratorAggregate, ArrayAccess, Countable { public $autostart = false; const COOKIE_MODE_NONE = 1; const COOKIE_MODE_ONLY = 2; const COOKIE_MODE_ALLOW = 3; const SESSION_SAVE_FILES = 'files'; const SESSION_SAVE_USER = 'user'; public static $read = array(); public static $write = array(); public function __construct($autostart = false) { $this->autostart = $autostart; } public function start() { if (!$this->isStart() && !$this->getAutoStart()) { $this->autostart ? $this->setAutoStart(1) : session_start(); } } public function isStart() { return '' !== $this->getSessionId(); } public function close() { if ($this->isStart()) { session_write_close(); } } public function get($name) { return isset($_SESSION[$name]) ? $_SESSION[$name] : null; } public function set($name, $value) { if (empty($name) && empty($value)) { return false; } $_SESSION[$name] = $value; return true; } public function remove($name) { if (isset($_SESSION[$name])) { $sessionValue = $_SESSION[$name]; unset($_SESSION[$name]); return $sessionValue; } return null; } public function exist($name) { return isset($_SESSION[$name]); } public function destroy() { if (($name = $this->getSessionName()) && isset($_COOKIE[$name])) { setcookie($name, '', time() - 3600); } session_unset(); session_destroy(); return true; } public function getSessionName() { return session_name(); } public function setSessionName($name) { return session_name($name); } public function getSessionId() { return session_id(); } public function setSessionId($id) { return session_id($id); } public function getSavePath() { return session_save_path(); } public function setSavePath($path) { if (is_dir($path)) { session_save_path($path); return true; } return false; } public function getSessionSaveMode() { return session_module_name(); } public function setSessionSaveMode($mode = self::SESSION_SAVE_FILES) { return session_module_name($mode); } public function getCookieParams() { return session_get_cookie_params(); } public function setCookieParams($cookie = array()) { extract($this->getCookieParams()); extract($cookie); if (isset($httponly)) { session_set_cookie_params($lifetime, $path, $domain, $secure, $httponly); } else { session_set_cookie_params($lifetime, $path, $domain, $secure); } return true; } public function getCookieMode() { if ('0' === ini_get('session.use_cookies')) { self::COOKIE_MODE_NONE; } else if ('0' === ini_get('session.use_only_cookies')) { return self::COOKIE_MODE_ALLOW; } else { return self::COOKIE_MODE_ONLY; } return false; } public function setCookieMode($mode = self::COOKIE_MODE_ONLY) { if (self::COOKIE_MODE_NONE === $mode) { ini_set('session.use_cookies', '0'); } else if (self::COOKIE_MODE_ALLOW === $mode) { ini_set('session.use_cookies', '1'); ini_set('session.use_only_cookies', '0'); } else if (self::COOKIE_MODE_ONLY === $mode) { ini_set('session.use_cookies', '1'); ini_set('session.use_only_cookies', '1'); } else { return false; } return true; } public function getGCProbability() { return (int) ini_get('session.gc_probability'); } public function setGCProbability($probability) { if (!is_int($probability) || 0 >= $probability || 100 <= $probability) { return false; } ini_set('session.gc_probability', $probability); ini_set('session.gc_divisor', '100'); return true; } public function getTransSessionID() { return '1' === ini_get('session.use_trans_sid'); } public function setTransSessionID($ifTrans = 0) { return ini_set('session.use_trans_sid', $ifTrans ? '1' : '0'); } public function getSessionLifeTime() { return (int) ini_get('session.gc_maxlifetime'); } public function setSessionLifeTime($time = 0) { return (int) ini_set('session.gc_maxlifetime', (int) $time); } public function getAutoStart() { return '1' === ini_get('session.auto_start'); } public function setAutoStart($autostart) { return ini_set('session.auto_start', $autostart ? '1' : '0'); } public function getCurrentSessionFileName(){ return $this->getSavePath().'/sess_'.$this->getSessionId(); } public function offsetExists($offset) { $this->exist($offset); } public function offsetSet($offset, $value) { $this->set($offset, $value); } public function offsetGet($offset) { $this->get($offset); } public function offsetUnset($offset) { $this->remove($offset); } public function getIterator($name = null) { return new ArrayObject(($name && isset($_SESSION[$name])) ? $_SESSION[$name] : $_SESSION); } public function count() { return count($_SESSION); } }   abstract class AbstractWindHttp { protected static $instance = null; protected $httpResource = null; protected $cookie = array(); protected $header = array(); protected $url = ''; protected $data = array(); protected $err = ''; protected $eno = 0; protected $timeout = 0; const _COOKIE = 'cookie'; const _HEADER = 'header'; const _DATA = 'data'; const GET = 'GET'; const POST = 'POST'; protected function __construct($url = '', $timeout = 5) { $this->url = $url; $this->timeout = $timeout; } public abstract function post($url = '', $data = array(), $header = array(), $cookie = array(), $options = array()); public abstract function get($url = '', $data = array(), $header = array(), $cookie = array(), $options = array()); public abstract function send($method = self::GET, $options = array()); public abstract function open(); public abstract function request($key, $value = null); public abstract function requestByArray($request = array()); public abstract function response(); public abstract function resonseLine(); public abstract function close(); public abstract function getError(); public static abstract function getInstance($url = ''); protected function __clone() {} public function setUrl($url) { $url && $this->url = $url; } public function setHeader($key, $value) { $this->header[$key] = $value; } public function setHeaders($headers = array()) { return $this->setPropertityValue(self::_HEADER, $headers); } public function setCookie($key, $value) { $this->cookie[$key] = $value; } public function setCookies($cookies = array()) { return $this->setPropertityValue(self::_COOKIE, $cookies); } public function setData($key, $value) { $this->data[$key] = $value; } public function setDatas($datas = array()) { return $this->setPropertityValue(self::_DATA, $datas); } public function clear() { $this->url = array(); $this->header = array(); $this->cookie = array(); $this->data = array(); } public static function buildQuery($query, $sep = '&') { if (!is_array($query)) { return ''; } $_query = ''; foreach ($query as $key => $value) { $tmp = rawurlencode($key) . '=' . rawurlencode($value); $_query .= $_query ? $sep . $tmp : $tmp; } return $_query; } public static function buildArray($array, $sep = ':') { if (!is_array($array)) { return array(); } $_array = array(); foreach ($array as $key => $value) { $_array[] = $key . $sep . $value; } return $_array; } private function setPropertityValue($propertity, $value = array()) { if (!in_array($propertity, array(self::_COOKIE, self::_DATA, self::_HEADER))) { return false; } if (!is_array($value)) { return false; } if (empty($this->$propertity)) { $this->$propertity = $value; } else { foreach ($value as $key => $_value) { $this->$propertity[$key] = $_value; } } return true; } }   Wind::import('WIND:component.http.transfer.AbstractWindHttp'); final class WindHttpCurl extends AbstractWindHttp { protected function __construct($url = '', $timeout = 5) { parent::__construct($url, $timeout); } public function open() { if (null === $this->httpResource) { $this->httpResource = curl_init(); } return $this->httpResource; } public function request($name, $value = null) { return curl_setopt($this->httpResource, $name, $value); } public function requestByArray($opt = array()) { return curl_setopt_array($this->httpResource, $opt); } public function response() { return curl_exec($this->httpResource); } public function resonseLine(){ return ''; } public function close() { if ($this->httpResource) { curl_close($this->httpResource); $this->httpResource = null; } } public function getError() { $this->err = curl_error($this->httpResource); $this->eno = curl_errno($this->httpResource); return $this->err ? $this->eno . ':' . $this->err : ''; } public function post($url = '', $data = array(), $header = array(), $cookie = array(), $option = array()) { $url && $this->setUrl($url); $header && is_array($header) && $this->setHeaders($header); $cookie && is_array($cookie) && $this->setCookies($cookie); $data && is_array($data) && $this->setDatas($data); return $this->send(self::POST, $option); } public function get($url = '', $data = array(), $header = array(), $cookie = array(), $option = array()) { $url && $this->setUrl($url); $header && is_array($header) && $this->setHeaders($header); $cookie && is_array($cookie) && $this->setCookies($cookie); $data && is_array($data) && $this->setDatas($data); return $this->send(self::GET, $option); } public function send($method = self::GET, $options = array()) { if (null === $this->httpResource) { $this->open(); } $this->request(CURLOPT_HEADER, 0); $this->request(CURLOPT_FOLLOWLOCATION, 1); $this->request(CURLOPT_RETURNTRANSFER, 1); $this->request(CURLOPT_TIMEOUT, $this->timeout); if ($options && is_array($options)) { $this->requestByArray($options); } if (self::GET === $method && $this->data) { $get = self::buildQuery($this->data, '&'); $url = parse_url($this->url); $sep = isset($url['query']) ? '&' : '?'; $this->url .= $sep . $get; } if (self::POST === $method && $this->data) { $this->request(CURLOPT_POST, 1); $this->request(CURLOPT_POSTFIELDS, self::buildQuery($this->data, '&')); } if ($this->cookie && $this->cookie) { $this->request(CURLOPT_COOKIE, self::buildQuery($this->cookie, ';')); } if (empty($this->header)) { $this->setHeader('User-Agent', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.1'); } $this->request(CURLOPT_HTTPHEADER, self::buildArray($this->header, ':')); $this->request(CURLOPT_URL, $this->url); return $this->response(); } public static function getInstance($url = '') { if (null === self::$instance || false === (self::$instance instanceof self)) { self::$instance = new self($url); } return self::$instance; } public function __destruct() { $this->close(); } }    Wind::import('WIND:component.http.transfer.AbstractWindHttp'); final class WindHttpSocket extends AbstractWindHttp { private $host = ''; private $port = 0; private $path = ''; private $query = ''; protected function __construct($url = '', $timeout = 5) { parent::__construct($url, $timeout); } public function open() { if (null === $this->httpResource) { $url = parse_url($this->url); $this->host = $url['host']; $this->port = isset($url['port']) && $url['port'] ? $url['port'] : 80; $this->path = isset($url['path']) && $url['path'] ? $url['path'] : '/'; $this->path .= $url['query'] ? '?' . $url['query'] : ''; $this->query = $url['query']; $this->httpResource = fsockopen($this->host, $this->port, $this->eno, $this->err, $this->timeout); } return $this->httpResource; } public function request($name, $value = null) { return fputs($this->httpResource, ($value ? $name . ': ' . $value : $name) . "\n"); } public function requestByArray($request = array()) { $_request = ''; foreach ($request as $key => $value) { if (is_string($key)) { $_request .= $key . ': ' . $value; } if (is_int($key)) { $_request .= $value; } $_request .= "\n"; } fputs($this->httpResource, $_request); } public function response() { $response = ''; while (!feof($this->httpResource)) { $response .= fgets($this->httpResource); } return $response; } public function resonseLine(){ return feof($this->httpResource) ? '' : fgets($this->httpResource); } public function close() { if ($this->httpResource) { fclose($this->httpResource); $this->httpResource = null; } } public function getError() { return $this->err ? $this->eno . ':' . $this->err : ''; } public function post($url = '', $data = array(), $header = array(), $cookie = array(), $option = array()) { $url && $this->setUrl($url); $header && is_array($header) && $this->setHeaders($header); $cookie && is_array($cookie) && $this->setCookies($cookie); $data && is_array($data) && $this->setDatas($data); return $this->send(self::POST, $option); } public function get($url = '', $data = array(), $header = array(), $cookie = array(), $option = array()) { $url && $this->setUrl($url); $header && is_array($header) && $this->setHeaders($header); $cookie && is_array($cookie) && $this->setCookies($cookie); $data && is_array($data) && $this->setDatas($data); return $this->send(self::GET, $option); } public function send($method = self::GET, $options = array()) { if (self::GET === $method && $this->data) { $url = parse_url($this->url); $get = self::buildQuery($this->data, '&'); $this->url .= ($url['query'] ? '&' : '?') . $get; } $this->open(); $this->setHeader("Host", $this->host); $this->setHeader('User-Agent', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.1)'); if ($this->cookie && $this->cookie) { $this->setHeader("Cookie", self::buildQuery($this->cookie, ';')); } if (self::POST === $method && $this->data) { $data = self::buildQuery($this->data, '&'); $this->setHeader('Content-Type', 'application/x-www-form-urlencoded'); $this->setHeader('Content-Length', strlen($data)); } if ($options) { $this->setHeaders($options); } $this->setHeader('Connection', 'Close'); $this->request($method . " " . $this->path . " HTTP/1.1"); $this->requestByArray($this->header); if ($data) { $this->request("\n" . $data); } $this->request("\n"); return $this->response(); } public static function getInstance($url = '') { if (null === self::$instance || false === (self::$instance instanceof self)) { self::$instance = new self($url); } return self::$instance; } public function __destruct() { $this->close(); } }   Wind::import('WIND:component.http.transfer.AbstractWindHttp'); final class WindHttpStream extends AbstractWindHttp { const HTTP = 'http'; const HTTPS = 'https'; const FTP = 'ftp'; const FTPS = 'ftp'; const SOCKET = 'socket'; private $context = null; private $wrapper = self::HTTP; protected function __construct($url = '', $timeout = 5) { parent::__construct($url, $timeout); $this->context = stream_context_create(); } public function setWrapper($wrapper = self::HTTP) { $this->wrapper = $wrapper; } public function open() { if (null === $this->httpResource) { $this->httpResource = fopen($this->url, 'r', false, $this->context); } return $this->httpResource; } public function request($name, $value = null) { return stream_context_set_option($this->context, $this->wrapper, $name, $value); } public function requestByArray($opt = array()) { foreach ($opt as $key => $value) { if (false === $this->request($key, $value)) { return false; } } return true; } public function response() { $response = ''; while (!feof($this->httpResource)) { $response .= fgets($this->httpResource); } return $response; } public function resonseLine(){ return feof($this->httpResource) ? '' : fgets($this->httpResource); } public function close() { if ($this->httpResource) { fclose($this->httpResource); $this->httpResource = null; $this->context = null; } } public function getError() { return $this->err ? $this->eno . ':' . $this->err : ''; } public function post($url = '', $data = array(), $header = array(), $cookie = array(), $option = array()) { $url && $this->setUrl($url); $header && is_array($header) && $this->setHeaders($header); $cookie && is_array($cookie) && $this->setCookies($cookie); $data && is_array($data) && $this->setDatas($data); return $this->send(self::POST, $option); } public function get($url = '', $data = array(), $header = array(), $cookie = array(), $option = array()) { $url && $this->setUrl($url); $header && is_array($header) && $this->setHeaders($header); $cookie && is_array($cookie) && $this->setCookies($cookie); $data && is_array($data) && $this->setDatas($data); return $this->send(self::GET, $option); } public function send($method = self::GET, $options = array()) { $url = parse_url($this->url); if (self::GET === $method && $this->data) { $get = self::buildQuery($this->data, '&'); $this->url .= ($url['query'] ? '&' : '?') . $get; } if (self::POST === $method && $this->data) { $data = self::buildQuery($this->data, '&'); $this->setHeader('Content-Type', 'application/x-www-form-urlencoded'); $this->setHeader('Content-Length', strlen($data)); } $this->setHeader("Host", $url['host']); $this->setHeader('User-Agent', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; InfoPath.1)'); if ($this->cookie) { $this->setHeader("Cookie", self::buildQuery($this->cookie, ';')); } $this->setHeader('Connection', 'Close'); $this->request('method', $method); $this->request('timeout', $this->timeout); if ($this->header) { $header = ''; foreach ($this->header as $key => $value) { $header .= $key . ': ' . $value . "\n"; } $this->request('header', $header); } $data && $this->request('content', $data); $options && is_array($options) && $this->requestByArray($options); $this->open(); return $this->response(); } public static function getInstance($url = '') { if (null === self::$instance || false === (self::$instance instanceof self)) { self::$instance = new self($url); } return self::$instance; } public function __destruct() { $this->close(); } }?>